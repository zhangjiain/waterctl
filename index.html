<!doctype html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8"/>
        <link rel="icon" href="favicon.ico"/>
        <meta name="viewport" content="width=device-width,initial-scale=1"/>
        <meta name="description" content="深圳市常工电子“蓝牙水控器”控制程序的开源实现。适用于国内各大高校宿舍热水器。"/>
        <meta name="theme-color" content="#fafafa"/>
        <link rel="apple-touch-icon" href="logo192.png"/>
        <link rel="manifest" href="./public/manifest.json"/>
        <title>TVS1-蓝牙水控器</title>
  <style>
   .misc {
      position: fixed;
      bottom: 0;
      width: 100%;
      text-align: center;
      background-color: transparent; /* 可根据需要设置背景颜色 */
    }
  </style>
        <script type="module" crossorigin>
            (function() {
                const e = document.createElement("link").relList;
                if (e && e.supports && e.supports("modulepreload"))
                    return;
                for (const o of document.querySelectorAll('link[rel="modulepreload"]'))
                    r(o);
                new MutationObserver(o => {
                    for (const s of o)
                        if (s.type === "childList")
                            for (const i of s.addedNodes)
                                i.tagName === "LINK" && i.rel === "modulepreload" && r(i)
                }
                ).observe(document, {
                    childList: !0,
                    subtree: !0
                });
                function n(o) {
                    const s = {};
                    return o.integrity && (s.integrity = o.integrity),
                    o.referrerPolicy && (s.referrerPolicy = o.referrerPolicy),
                    o.crossOrigin === "use-credentials" ? s.credentials = "include" : o.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
                    s
                }
                function r(o) {
                    if (o.ep)
                        return;
                    o.ep = !0;
                    const s = n(o);
                    fetch(o.href, s)
                }
            }
            )();
            const bt = [];
            function on(t) {
                console.log(t),
                bt.push(t)
            }
            function jn() {
                bt.length = 0
            }
            function Wn() {
                return bt.length === 0
            }
            function Yn() {
                return Object.freeze(bt)
            }
            function sn(t) {
                return Array.from(new Uint8Array(t)).map(e => e.toString(16).padStart(2, "0")).join("").toUpperCase()
            }
            function ee(t) {
                return t <= 0 ? 0 : t % 10 | ee(t / 10 | 0) << 4
            }
            function Ee() {
                const t = navigator.userAgent.toLowerCase();
                return /android|iphone|ipod|ipad/i.test(t)
            }
            if (typeof BluetoothRemoteGATTCharacteristic < "u") {
                const t = BluetoothRemoteGATTCharacteristic.prototype.writeValue;
                BluetoothRemoteGATTCharacteristic.prototype.writeValue = function(e) {
                    const n = "TXD: " + sn(e);
                    return on(n),
                    t.apply(this, arguments)
                }
            }
            const Vn = [{
                isHit: t => !!t.match(/WATERCTL INTERNAL Unknown RXD data/),
                output: t => {
                    t.innerText = `接收到未知数据。可能不影响使用。

这可能是一个 Bug，请截图并`,
                    t.innerHTML += "<a href='https://github.com/celesWuff/waterctl' target='_blank'>反馈给开发者</a>。"
                }
                ,
                isFatal: !1,
                showLogs: !0
            }, {
                isHit: t => !!t.match(/WATERCTL INTERNAL (?:Refused|Bad key)/),
                output: t => {
                    t.innerText = `水控器拒绝启动。

蓝牙水控器 FOSS 当前不支持您的水控器，请不要重试，多次失败可能造成水控器锁定。
若发生锁定，水控器将拒绝一切传入连接；在通电状态下等待约一小时方可恢复。

请截图并`,
                    t.innerHTML += "<a href='https://github.com/celesWuff/waterctl' target='_blank'>反馈给开发者</a>。"
                }
                ,
                isFatal: !0,
                showLogs: !0
            }, {
                isHit: t => !!t.match(/WATERCTL INTERNAL Operation timed out/),
                output: t => {
                    t.innerText = `等待时间似乎太长了。

如果该问题反复发生，这可能是一个 Bug，请截图并`,
                    t.innerHTML += "<a href='https://github.com/celesWuff/waterctl' target='_blank'>反馈给开发者</a>。"
                }
                ,
                isFatal: !1,
                showLogs: !0
            }, {
                isHit: t => !!t.match(/User denied the browser permission/) || Ee() && !!t.match(/NotFoundError|Bluetooth adapter not available/),
                output: t => {
                    t.innerText = `未授予蓝牙权限。

请前往手机设置，授予浏览器“附近设备”权限。
详情请参考源代码仓库内的`,
                    t.innerHTML += "<a href='https://github.com/celesWuff/waterctl/blob/2.x/FAQ.md' target='_blank'>“疑难解答”</a>。"
                }
                ,
                isFatal: !0,
                showLogs: !1
            }, {
                isHit: t => !Ee() && !!t.match(/NotFoundError|Bluetooth adapter not available/),
                output: t => {
                    t.innerText = `设备不支持蓝牙，或未授予蓝牙权限。

详情请参考源代码仓库内的`,
                    t.innerHTML += "<a href='https://github.com/celesWuff/waterctl/blob/2.x/FAQ.md' target='_blank'>“疑难解答”</a>。"
                }
                ,
                isFatal: !0,
                showLogs: !1
            }, {
                isHit: t => !!t.match(/NetworkError|GATT operation failed/),
                output: t => {
                    t.innerText = `连接不稳定，无法与水控器建立连接。
请重试。`
                }
                ,
                isFatal: !0,
                showLogs: !1
            }, {
                isHit: () => !0,
                output: (t, e) => {
                    t.innerText = e + `

是什么呢

（这可能是一个 Bug，请截图并`,
                    t.innerHTML += "<a href='https://github.com/celesWuff/waterctl' target='_blank'>反馈给开发者</a>。）"
                }
                ,
                isFatal: !0,
                showLogs: !0
            }];
            function zn(t) {
                for (const e of Vn)
                    if (e.isHit(t.toString()))
                        return e;
                throw new Error(`WATERCTL INTERNAL Unhandled: ${t}`)
            }
            const Xn = new Uint8Array([254, 254, 9, 176, 1, 1, 0, 0])
              , Jn = new Uint8Array([254, 254, 9, 179, 0, 0])
              , qn = new Uint8Array([254, 254, 9, 180, 0, 0])
              , Kn = new Uint8Array([254, 254, 9, 188, 0, 0])
              , Zn = new Uint8Array([254, 254, 9, 186, 0, 0]);
            function tr(t) {
                let e = 4119;
                for (let n = 0; n < t.length; n++) {
                    e ^= t.charCodeAt(n);
                    for (let r = 0; r < 8; r++)
                        (e & 1) == 1 ? (e >>= 1,
                        e ^= 40961) : e >>= 1
                }
                return e
            }
            function er(t) {
                let e = 27167;
                for (let n = 0; n < t.length; n++) {
                    e ^= t[n];
                    for (let r = 0; r < 8; r++)
                        (e & 1) == 1 ? (e >>= 1,
                        e ^= 40961) : e >>= 1
                }
                return e = (e ^ 117) & 255,
                e
            }
            const nr = async (t={}, e) => {
                let n;
                if (e.startsWith("data:")) {
                    const r = e.replace(/^data:.*?base64,/, "");
                    let o;
                    if (typeof Buffer == "function" && typeof Buffer.from == "function")
                        o = Buffer.from(r, "base64");
                    else if (typeof atob == "function") {
                        const s = atob(r);
                        o = new Uint8Array(s.length);
                        for (let i = 0; i < s.length; i++)
                            o[i] = s.charCodeAt(i)
                    } else
                        throw new Error("Failed to decode base64-encoded data URL, Buffer and atob are not supported");
                    n = await WebAssembly.instantiate(o, t)
                } else {
                    const r = await fetch(e)
                      , o = r.headers.get("Content-Type") || "";
                    if ("instantiateStreaming"in WebAssembly && o.startsWith("application/wasm"))
                        n = await WebAssembly.instantiateStreaming(r, t);
                    else {
                        const s = await r.arrayBuffer();
                        n = await WebAssembly.instantiate(s, t)
                    }
                }
                return n.instance
            }
              , rr = t => nr(t, "data:application/wasm;base64,AGFzbQEAAAABCAFgBH9/f38AAwIBAAUDAQABBxQCBm1lbW9yeQIAB21ha2VLZXkAAAq7BAG4BAEFfyABQf8BRiAAQQFxQQFGcQRAIABBAmohAAsgAEGBAkYEQEEAIQALIANBB3EhBCADQX9BB3NxIQggCEEBQQN0cQRAIARBBHMhBAsgCEEBQQR0cQRAIARBBHMhBAsgCEEBQQV0cQRAIARBBHMhBAsgCEEBQQZ0cQRAIARBBHMhBAsgCEEBQQd0cQRAIARBBHMhBAsgBEEAIAFqLQAAcyEEIABBAUEAdHEEQCAEQQFzIQQLIABBAUEBdHEEQCAEQQFzIQQLIABBAUECdHEEQCAEQQJzIQQLIABBAUEDdHEEQCAEQQdzIQQLIABBAUEEdHEEQCAEQQFzIQQLIABBAUEFdHEEQCAEQQFzIQQLIABBAUEGdHEEQCAEQQFzIQQLIABBAUEHdHEEQCAEQQFzIQQLIAJBB3EhBiACQX9BB3NxIQggCEEBQQN0cQRAIAZBBHMhBgsgCEEBQQR0cQRAIAZBBHMhBgsgCEEBQQV0cQRAIAZBBHMhBgsgCEEBQQZ0cQRAIAZBBHMhBgsgCEEBQQd0cQRAIAZBBHMhBgsgBkGABiABQQ9xai0AAHMhBkGAAiABai0AACADcyEDQYAEIABqLQAAIANzIQNBkAogA2otAAAhBUGQBiABai0AACACcyECQZAIIABqLQAAIAJzIQJBkAwgAmotAAAhB0GzEEGSDyAEai0AADoAAEGyEEGQDiAFai0AADoAAEGxEEGiECAGai0AADoAAEGwEEGgDyAHai0AADoAAAsLtxABAEEAC7AQAAQFAAEFBAABBQQBAAQFAAEFBAEABAUBAAQFAAEFBAABBQQBAAQFAQAEBQABBQQBAAQFAAEFBAABBQQBAAQFAAEFBAEABAUBAAQFAAEFBAEABAUAAQUEAAEFBAEABAUBAAQFAAEFBAABBQQBAAQFAAEFBAEABAUBAAQFAAEFBAABBQQBAAQFAQAEBQABBQQBAAQFAAEFBAABBQQBAAQFAQAEBQABBQQAAQUEAQAEBQABBQQBAAQFAQAEBQABBQQBAAQFAAEFBAABBQQBAAQFAAEFBAEABAUBAAQFAAEFBAABBQQBAAQFAQAEBQABBQQBAAQFAAEFBAABBQQBAAQFAABAgcABQYDAAUGAwQBAgcABQYDBAECBwQBAgcABQYDAAUGAwQBAgcEAQIHAAUGAwQBAgcABQYDAAUGAwQBAgcABQYDBAECBwQBAgcABQYDBAECBwAFBgMABQYDBAECBwQBAgcABQYDAAUGAwQBAgcABQYDBAECBwQBAgcABQYDAAUGAwQBAgcEAQIHAAUGAwQBAgcABQYDAAUGAwQBAgcEAQIHAAUGAwAFBgMEAQIHAAUGAwQBAgcEAQIHAAUGAwQBAgcABQYDAAUGAwQBAgcABQYDBAECBwQBAgcABQYDAAUGAwQBAgcEAQIHAAUGAwQBAgcABQYDAAUGAwQBAgcAAAQEAAgMDAgcGBgcFBAQFDQwMDQ8ODg8KCwsKCAkJCBkYGBkbGhobHh8fHhwdHRwUFRUUFhcXFhMSEhMREBARMTAwMTMyMjM2Nzc2NDU1NDw9PTw+Pz8+Ozo6Ozk4ODkoKSkoKisrKi8uLi8tLCwtJSQkJScmJiciIyMiICEhIGFgYGFjYmJjZmdnZmRlZWRsbW1sbm9vbmtqamtpaGhpeHl5eHp7e3p/fn5/fXx8fXV0dHV3dnZ3cnNzcnBxcXBQUVFQUlNTUldWVldVVFRVXVxcXV9eXl9aW1taWFlZWElISElLSkpLTk9PTkxNTUxERUVERkdHRkNCQkNBQEBBAAEBAwMCAgYGBwcFBQQEAAABwQPDwgIGxscHxQUExAzMzQ3PDw7OygoLywnJyAgY2NkZ2xsa2t4eH98d3dwc1BQV1RfX1hYS0tMT0REQ0DDw8THzMzLy9jY39zX19DT8PD39P//+Pjr6+zv5OTj46Cgp6Svr6iou7u8v7S0s7CTk5SXnJybm4iIj4yHh4CBgoKFho2NioqZmZ6dlpaRkrGxtrW+vrm5qqqtrqWloqLh4ebl7u7p6fr6/f719fLx0tLV1t3d2trJyc7NxsbBwkFBRkVOTklJWlpdXlVVUlFycnV2fX16emlpbm1mZmFhIiIlJi0tKio5OT49NjYxMhERFhUeHhkZCgoNDgUFAgFAAkGDwwFCgMMBQoDAAkGDwwFCgMACQYPAAkGDwwFCgMMBQoDAAkGDwAJBg8MBQoDAAkGDwwFCgMMBQoDAAkGDwwFCgMACQYPAAkGDwwFCgMACQYPDAUKAwwFCgMACQYPAAkGDwwFCgMMBQoDAAkGDwwFCgMACQYPAAkGDwwFCgMMBQoDAAkGDwAJBg8MBQoDAAkGDwwFCgMMBQoDAAkGDwAJBg8MBQoDDAUKAwAJBg8MBQoDAAkGDwAJBg8MBQoDAAkGDwwFCgMMBQoDAAkGDwwFCgMACQYPAAkGDwwFCgMMBQoDAAkGDwAJBg8MBQoDAAkGDwwFCgMMBQoDAAkGDwAAECAwQFBgcICQoLDA0ODxAREhMRFBEVFhcYGRobHB0THh8gISIPIxghJBAjJSYfIicoKSorLC0lIA8MEy4vKjAXMTIzNDU2NzgDOToNJDknIiUGOzw9Pj8FD0BBQkM6REVGLx4FK0cTSElKSx8bPkxNIA5MTk9QUVIxHklTIlQYVVYQV1hZWkIkDVszXF0UIF5DXx1WVQs6YGFBYjk3Y2QEBmUIZmdoESBpF2EbHmoxFms2bAc4bW48Um8mQXAncVo0RHJzAUwKahYcdBkWK1FOdRJcPRVdAiJTTxFpdikJWXcbeER5ensFD3wrAX0sVQYFfgx/gA8AGoEDMR48eAABAgMABAUGBwgJCgsMDQ4DDxAREhMUFRYXGBkaGxwdFh4fICEiIyQlJhQnKCkqKywcLSInDC4vMDEyMzQ1NjMTNAI3ODk6OzwaFD0EPj9AQUIeQ0RFDUZHSElIJEpISx9MG01LAU5FTRMcTjUfJyRPKFAkNxM1G1FSJk9TVB0cJkZEVUJGVjkzP1dYKwlZWlNbXEgxLRw+XUcXXkpfMi9SYD8mYRMUYmNkK2UeZmc6ZRgnDARoQ0ATaWo3axQabEldXgptAgEQWWdub0twbEVxBgByEXN0AzhscEF1D3Y1Vicecw1cNUh3eHk7eho9ex18EUx9Lhh+fwU8gAeBRgx1N1Ih9tVI2KC5vMySOVTz+T7iV6NbxlXRlzJmxWTANGXJUb1h1xJFcmqsWSDKXzDBY2fNWDUjXFrU8l2nFPVgOEbEpmhAJ6IcqdNBMZH40AQMx4kkVtJCGEPwCqQZGza3zyJt2fcWSRU9oWJTOhOo9Mi66x5EbxDDD6VQ1mkA8Xfpz/Ki1bdGwFkgQ0VMRVPUYTnyIVpcIzVYzWdjVcGmxEY489Vg9RSnXUjXUUVmNEHTqRxXolnAMCdAaCSJxwwE0PgxVGWRksy8uaDY9lI3dWTFMpfRxls+o+L5Er3JrF/KIGpyHqHruvDIbz0ZpERp1lClD8MQQ+l38QBWChhC0m0iz7c2GxVJFvfZ9KgTOlNiMevz17o3ZZJXVUZGPDM=");
            function or() {
                const t = Math.floor(Math.random() * 9999) + 1;
                return new Uint8Array([t >> 8, t & 255]).map(ee)
            }
            function sr() {
                const t = new Date().toLocaleString("zh-CN", {
                    timeZone: "Asia/Shanghai"
                })
                  , e = t.split(" ")[0].split("/").map(o => parseInt(o))
                  , n = t.split(" ")[1].split(":").map(o => parseInt(o));
                return [e[0] % 100, ...e.slice(1), ...n].map(ee)
            }
            async function ir(t) {
                const {makeKey: e, memory: n} = (await rr()).exports;
                if (t.length !== 4)
                    throw new Error("WATERCTL INTERNAL Bad unlock request");
                e(...t);
                const r = new Uint32Array(n.buffer)[524];
                return new Uint8Array([r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, r & 255])
            }
            async function ar(t, e) {
                const n = new Uint8Array(t)
                  , r = n[5]
                  , o = n.slice(6, 8)
                  , s = n.slice(8, 10)
                  , i = o[0] << 8 | o[1]
                  , a = i + 1
                  , c = i === 65535 ? new Uint8Array([1, 0]) : new Uint8Array([a >> 8 & 255, a & 255])
                  , u = await ir(new Uint8Array([...o, ...s]))
                  , l = e.slice(-4).split("").map(B => B.charCodeAt(0) - 48)
                  , f = u.map( (B, y) => B ^ l[y])
                  , g = new Uint8Array([r, ...c, ...f, 254, 135, 0, 0, 0, 0, 0, 0])
                  , d = er(g);
                return new Uint8Array([254, 254, 9, 175, d, ...g])
            }
            function Nt(t, e=!1) {
                const n = tr(t.slice(-5))
                  , r = e ? 11 : 255
                  , o = or()
                  , s = sr();
                return new Uint8Array([254, 254, 9, 178, 1, n & 255, n >> 8, r, 0, ...o, ...s, 15, 39, 0])
            }
            let C, D, Qt, ne = !1, nt, _t;
            function re(t) {
                const e = document.getElementById("main-button")
                  , n = document.getElementById("device-name");
                switch (t) {
                case "pending":
                    e.innerText = "请稍候",
                    e.disabled = !0,
                    n.innerText = "已连接：" + C.name;
                    break;
                case "ok":
                    e.innerText = "结束",
                    e.disabled = !1;
                    break;
                case "standby":
                    e.innerText = "开启",
                    e.disabled = !1,
                    n.innerText = "未连接";
                    break
                }
            }
            async function an() {
                C && C.gatt.disconnect(),
                ne = !1,
                jn(),
                clearTimeout(nt),
                clearTimeout(_t),
                re("standby")
            }
            async function wt(t) {
                if (!t)
                    throw t;
                const e = t.toString();
                if (e.match(/User cancelled/) || e == "2")
                    return;
                const n = document.getElementById("dialog-content")
                  , r = document.getElementById("dialog-debug-container")
                  , o = document.getElementById("dialog-debug-content")
                  , {output: s, isFatal: i, showLogs: a} = zn(t);
                throw s(n, t),
                r.style.display = "none",
                !Wn() && a && (r.style.display = "block",
                o.innerText = `调试信息：
` + Yn().join(`
`)),
                document.getElementById("dialog").showModal(),
                i && an(),
                t
            }
            async function cr(t) {
                const e = t.target.value;
                on("RXD: " + sn(e.buffer));
                try {
                    let n = new Uint8Array(e.buffer);
                    if (n[0] === 65 && n[1] === 84 && n[2] === 43)
                        return;
                    if (n[0] !== 253 && n[0] !== 9)
                        throw new Error("WATERCTL INTERNAL Unknown RXD data");
                    if (n[1] === 9 && (n = new Uint8Array([253, ...n])),
                    n[0] === 9 && (n = new Uint8Array([253, 253, ...n])),
                    n.length < 4)
                        return;
                    switch (n[3]) {
                    case 176:
                    case 177:
                        clearTimeout(nt),
                        nt = setTimeout( () => {
                            D.writeValue(Nt(C.name))
                        }
                        , 500);
                        break;
                    case 174:
                        clearTimeout(nt),
                        await D.writeValue(await ar(n, C.name));
                        break;
                    case 175:
                        switch (n[5]) {
                        case 85:
                            await D.writeValue(Nt(C.name, !0));
                            break;
                        case 1:
                        case 2:
                        case 4:
                            throw new Error("WATERCTL INTERNAL Bad key");
                        default:
                            throw await D.writeValue(Nt(C.name, !0)),
                            new Error("WATERCTL INTERNAL Unknown RXD data")
                        }
                        break;
                    case 178:
                        clearTimeout(nt),
                        clearTimeout(_t),
                        ne = !0,
                        re("ok");
                        break;
                    case 179:
                        await D.writeValue(qn),
                        an();
                        break;
                    case 170:
                    case 181:
                    case 184:
                        break;
                    case 186:
                        await D.writeValue(Zn);
                        break;
                    case 188:
                        await D.writeValue(Kn);
                        break;
                    case 200:
                        throw new Error("WATERCTL INTERNAL Refused");
                    default:
                        throw new Error("WATERCTL INTERNAL Unknown RXD data")
                    }
                } catch (n) {
                    wt(n)
                }
            }
            function cn() {
                _t || (_t = setTimeout( () => {
                    wt("WATERCTL INTERNAL Operation timed out")
                }
                , 15e3))
            }
            async function ur() {
                try {
                    C = await navigator.bluetooth.requestDevice({
                        filters: Array.from("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ").map(n => ({
                            namePrefix: n
                        })),
                        optionalServices: [window.navigator.userAgent.match(/Bluefy/) ? "generic_access" : 61936]
                    }),
                    re("pending");
                    const e = await (await C.gatt.connect()).getPrimaryService(61936);
                    D = await e.getCharacteristic(61937),
                    Qt = await e.getCharacteristic(61938),
                    await Qt.startNotifications(),
                    Qt.addEventListener("characteristicvaluechanged", cr),
                    await D.writeValue(Xn),
                    cn()
                } catch (t) {
                    wt(t)
                }
            }
            async function fr() {
                try {
                    await D.writeValue(Jn),
                    cn()
                } catch (t) {
                    wt(t)
                }
            }
            function lr() {
                ne ? fr() : ur()
            }
            const dr = () => {
                navigator.serviceWorker && !navigator.serviceWorker.controller && location.protocol === "https:" && navigator.serviceWorker.register("./public/serviceworker.js")
            }
              , pr = () => {
                const t = document.getElementById("install-button");
                window.addEventListener("beforeinstallprompt", e => {
                    e.preventDefault(),
                    window.deferredPrompt = e,
                    t.hidden = !1
                }
                ),
                t.addEventListener("click", async () => {
                    const e = window.deferredPrompt;
                    e && (e.prompt(),
                    await e.userChoice,
                    window.deferredPrompt = null,
                    t.hidden = !0)
                }
                ),
                window.addEventListener("appinstalled", () => {
                    window.deferredPrompt = null
                }
                )
            }
              , gr = () => {
                window.resizeTo(538, 334)
            }
              , h = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
              , m = globalThis
              , W = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
              , P = "9.4.0";
            function Bt() {
                return It(m),
                m
            }
            function It(t) {
                const e = t.__SENTRY__ = t.__SENTRY__ || {};
                return e.version = e.version || P,
                e[P] = e[P] || {}
            }
            function Tt(t, e, n=m) {
                const r = n.__SENTRY__ = n.__SENTRY__ || {}
                  , o = r[P] = r[P] || {};
                return o[t] || (o[t] = e())
            }
            const hr = "Sentry Logger "
              , Pt = ["debug", "info", "warn", "error", "log", "assert", "trace"]
              , Et = {};
            function tt(t) {
                if (!("console"in m))
                    return t();
                const e = m.console
                  , n = {}
                  , r = Object.keys(Et);
                r.forEach(o => {
                    const s = Et[o];
                    n[o] = e[o],
                    e[o] = s
                }
                );
                try {
                    return t()
                } finally {
                    r.forEach(o => {
                        e[o] = n[o]
                    }
                    )
                }
            }
            function mr() {
                let t = !1;
                const e = {
                    enable: () => {
                        t = !0
                    }
                    ,
                    disable: () => {
                        t = !1
                    }
                    ,
                    isEnabled: () => t
                };
                return W ? Pt.forEach(n => {
                    e[n] = (...r) => {
                        t && tt( () => {
                            m.console[n](`${hr}[${n}]:`, ...r)
                        }
                        )
                    }
                }
                ) : Pt.forEach(n => {
                    e[n] = () => {}
                }
                ),
                e
            }
            const p = Tt("logger", mr)
              , un = 50
              , U = "?"
              , ye = /\(error: (.*)\)/
              , Ae = /captureMessage|captureException/;
            function fn(...t) {
                const e = t.sort( (n, r) => n[0] - r[0]).map(n => n[1]);
                return (n, r=0, o=0) => {
                    const s = []
                      , i = n.split(`
`);
                    for (let a = r; a < i.length; a++) {
                        const c = i[a];
                        if (c.length > 1024)
                            continue;
                        const u = ye.test(c) ? c.replace(ye, "$1") : c;
                        if (!u.match(/\S*Error: /)) {
                            for (const l of e) {
                                const f = l(u);
                                if (f) {
                                    s.push(f);
                                    break
                                }
                            }
                            if (s.length >= un + o)
                                break
                        }
                    }
                    return Er(s.slice(o))
                }
            }
            function _r(t) {
                return Array.isArray(t) ? fn(...t) : t
            }
            function Er(t) {
                if (!t.length)
                    return [];
                const e = Array.from(t);
                return /sentryWrapped/.test(ut(e).function || "") && e.pop(),
                e.reverse(),
                Ae.test(ut(e).function || "") && (e.pop(),
                Ae.test(ut(e).function || "") && e.pop()),
                e.slice(0, un).map(n => ({
                    ...n,
                    filename: n.filename || ut(e).filename,
                    function: n.function || U
                }))
            }
            function ut(t) {
                return t[t.length - 1] || {}
            }
            const xt = "<anonymous>";
            function M(t) {
                try {
                    return !t || typeof t != "function" ? xt : t.name || xt
                } catch {
                    return xt
                }
            }
            function Se(t) {
                const e = t.exception;
                if (e) {
                    const n = [];
                    try {
                        return e.values.forEach(r => {
                            r.stacktrace.frames && n.push(...r.stacktrace.frames)
                        }
                        ),
                        n
                    } catch {
                        return
                    }
                }
            }
            const ht = {}
              , be = {};
            function Y(t, e) {
                ht[t] = ht[t] || [],
                ht[t].push(e)
            }
            function V(t, e) {
                if (!be[t]) {
                    be[t] = !0;
                    try {
                        e()
                    } catch (n) {
                        W && p.error(`Error while instrumenting ${t}`, n)
                    }
                }
            }
            function k(t, e) {
                const n = t && ht[t];
                if (n)
                    for (const r of n)
                        try {
                            r(e)
                        } catch (o) {
                            W && p.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${M(r)}
Error:`, o)
                        }
            }
            let Ft = null;
            function yr(t) {
                const e = "error";
                Y(e, t),
                V(e, Ar)
            }
            function Ar() {
                Ft = m.onerror,
                m.onerror = function(t, e, n, r, o) {
                    return k("error", {
                        column: r,
                        error: o,
                        line: n,
                        msg: t,
                        url: e
                    }),
                    Ft ? Ft.apply(this, arguments) : !1
                }
                ,
                m.onerror.__SENTRY_INSTRUMENTED__ = !0
            }
            let Mt = null;
            function Sr(t) {
                const e = "unhandledrejection";
                Y(e, t),
                V(e, br)
            }
            function br() {
                Mt = m.onunhandledrejection,
                m.onunhandledrejection = function(t) {
                    return k("unhandledrejection", t),
                    Mt ? Mt.apply(this, arguments) : !0
                }
                ,
                m.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
            }
            const ln = Object.prototype.toString;
            function oe(t) {
                switch (ln.call(t)) {
                case "[object Error]":
                case "[object Exception]":
                case "[object DOMException]":
                case "[object WebAssembly.Exception]":
                    return !0;
                default:
                    return G(t, Error)
                }
            }
            function et(t, e) {
                return ln.call(t) === `[object ${e}]`
            }
            function dn(t) {
                return et(t, "ErrorEvent")
            }
            function we(t) {
                return et(t, "DOMError")
            }
            function wr(t) {
                return et(t, "DOMException")
            }
            function N(t) {
                return et(t, "String")
            }
            function se(t) {
                return typeof t == "object" && t !== null && "__sentry_template_string__"in t && "__sentry_template_values__"in t
            }
            function ie(t) {
                return t === null || se(t) || typeof t != "object" && typeof t != "function"
            }
            function X(t) {
                return et(t, "Object")
            }
            function kt(t) {
                return typeof Event < "u" && G(t, Event)
            }
            function Br(t) {
                return typeof Element < "u" && G(t, Element)
            }
            function Ir(t) {
                return et(t, "RegExp")
            }
            function Dt(t) {
                return !!(t != null && t.then && typeof t.then == "function")
            }
            function Tr(t) {
                return X(t) && "nativeEvent"in t && "preventDefault"in t && "stopPropagation"in t
            }
            function G(t, e) {
                try {
                    return t instanceof e
                } catch {
                    return !1
                }
            }
            function pn(t) {
                return !!(typeof t == "object" && t !== null && (t.__isVue || t._isVue))
            }
            const ae = m
              , kr = 80;
            function gn(t, e={}) {
                if (!t)
                    return "<unknown>";
                try {
                    let n = t;
                    const r = 5
                      , o = [];
                    let s = 0
                      , i = 0;
                    const a = " > "
                      , c = a.length;
                    let u;
                    const l = Array.isArray(e) ? e : e.keyAttrs
                      , f = !Array.isArray(e) && e.maxStringLength || kr;
                    for (; n && s++ < r && (u = Dr(n, l),
                    !(u === "html" || s > 1 && i + o.length * c + u.length >= f)); )
                        o.push(u),
                        i += u.length,
                        n = n.parentNode;
                    return o.reverse().join(a)
                } catch {
                    return "<unknown>"
                }
            }
            function Dr(t, e) {
                const n = t
                  , r = [];
                if (!(n != null && n.tagName))
                    return "";
                if (ae.HTMLElement && n instanceof HTMLElement && n.dataset) {
                    if (n.dataset.sentryComponent)
                        return n.dataset.sentryComponent;
                    if (n.dataset.sentryElement)
                        return n.dataset.sentryElement
                }
                r.push(n.tagName.toLowerCase());
                const o = e != null && e.length ? e.filter(i => n.getAttribute(i)).map(i => [i, n.getAttribute(i)]) : null;
                if (o != null && o.length)
                    o.forEach(i => {
                        r.push(`[${i[0]}="${i[1]}"]`)
                    }
                    );
                else {
                    n.id && r.push(`#${n.id}`);
                    const i = n.className;
                    if (i && N(i)) {
                        const a = i.split(/\s+/);
                        for (const c of a)
                            r.push(`.${c}`)
                    }
                }
                const s = ["aria-label", "type", "name", "title", "alt"];
                for (const i of s) {
                    const a = n.getAttribute(i);
                    a && r.push(`[${i}="${a}"]`)
                }
                return r.join("")
            }
            function ce() {
                try {
                    return ae.document.location.href
                } catch {
                    return ""
                }
            }
            function vr(t) {
                if (!ae.HTMLElement)
                    return null;
                let e = t;
                const n = 5;
                for (let r = 0; r < n; r++) {
                    if (!e)
                        return null;
                    if (e instanceof HTMLElement) {
                        if (e.dataset.sentryComponent)
                            return e.dataset.sentryComponent;
                        if (e.dataset.sentryElement)
                            return e.dataset.sentryElement
                    }
                    e = e.parentNode
                }
                return null
            }
            function z(t, e=0) {
                return typeof t != "string" || e === 0 || t.length <= e ? t : `${t.slice(0, e)}...`
            }
            function Be(t, e) {
                if (!Array.isArray(t))
                    return "";
                const n = [];
                for (let r = 0; r < t.length; r++) {
                    const o = t[r];
                    try {
                        pn(o) ? n.push("[VueViewModel]") : n.push(String(o))
                    } catch {
                        n.push("[value cannot be serialized]")
                    }
                }
                return n.join(e)
            }
            function Rr(t, e, n=!1) {
                return N(t) ? Ir(e) ? e.test(t) : N(e) ? n ? t === e : t.includes(e) : !1 : !1
            }
            function vt(t, e=[], n=!1) {
                return e.some(r => Rr(t, r, n))
            }
            function b(t, e, n) {
                if (!(e in t))
                    return;
                const r = t[e]
                  , o = n(r);
                typeof o == "function" && hn(o, r);
                try {
                    t[e] = o
                } catch {
                    W && p.log(`Failed to replace method "${e}" in object`, t)
                }
            }
            function $(t, e, n) {
                try {
                    Object.defineProperty(t, e, {
                        value: n,
                        writable: !0,
                        configurable: !0
                    })
                } catch {
                    W && p.log(`Failed to add non-enumerable property "${e}" to object`, t)
                }
            }
            function hn(t, e) {
                try {
                    const n = e.prototype || {};
                    t.prototype = e.prototype = n,
                    $(t, "__sentry_original__", e)
                } catch {}
            }
            function ue(t) {
                return t.__sentry_original__
            }
            function mn(t) {
                if (oe(t))
                    return {
                        message: t.message,
                        name: t.name,
                        stack: t.stack,
                        ...Te(t)
                    };
                if (kt(t)) {
                    const e = {
                        type: t.type,
                        target: Ie(t.target),
                        currentTarget: Ie(t.currentTarget),
                        ...Te(t)
                    };
                    return typeof CustomEvent < "u" && G(t, CustomEvent) && (e.detail = t.detail),
                    e
                } else
                    return t
            }
            function Ie(t) {
                try {
                    return Br(t) ? gn(t) : Object.prototype.toString.call(t)
                } catch {
                    return "<unknown>"
                }
            }
            function Te(t) {
                if (typeof t == "object" && t !== null) {
                    const e = {};
                    for (const n in t)
                        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                    return e
                } else
                    return {}
            }
            function Cr(t, e=40) {
                const n = Object.keys(mn(t));
                n.sort();
                const r = n[0];
                if (!r)
                    return "[object has no keys]";
                if (r.length >= e)
                    return z(r, e);
                for (let o = n.length; o > 0; o--) {
                    const s = n.slice(0, o).join(", ");
                    if (!(s.length > e))
                        return o === n.length ? s : z(s, e)
                }
                return ""
            }
            function w(t) {
                return Ut(t, new Map)
            }
            function Ut(t, e) {
                if (Nr(t)) {
                    const n = e.get(t);
                    if (n !== void 0)
                        return n;
                    const r = {};
                    e.set(t, r);
                    for (const o of Object.getOwnPropertyNames(t))
                        typeof t[o] < "u" && (r[o] = Ut(t[o], e));
                    return r
                }
                if (Array.isArray(t)) {
                    const n = e.get(t);
                    if (n !== void 0)
                        return n;
                    const r = [];
                    return e.set(t, r),
                    t.forEach(o => {
                        r.push(Ut(o, e))
                    }
                    ),
                    r
                }
                return t
            }
            function Nr(t) {
                if (!X(t))
                    return !1;
                try {
                    const e = Object.getPrototypeOf(t).constructor.name;
                    return !e || e === "Object"
                } catch {
                    return !0
                }
            }
            const _n = 1e3;
            function st() {
                return Date.now() / _n
            }
            function Qr() {
                const {performance: t} = m;
                if (!(t != null && t.now))
                    return st;
                const e = Date.now() - t.now()
                  , n = t.timeOrigin == null ? e : t.timeOrigin;
                return () => (n + t.now()) / _n
            }
            const Q = Qr();
            function xr() {
                const t = m;
                return t.crypto || t.msCrypto
            }
            function I(t=xr()) {
                let e = () => Math.random() * 16;
                try {
                    if (t != null && t.randomUUID)
                        return t.randomUUID().replace(/-/g, "");
                    t != null && t.getRandomValues && (e = () => {
                        const n = new Uint8Array(1);
                        return t.getRandomValues(n),
                        n[0]
                    }
                    )
                } catch {}
                return ("10000000100040008000" + 1e11).replace(/[018]/g, n => (n ^ (e() & 15) >> n / 4).toString(16))
            }
            function En(t) {
                var e, n;
                return (n = (e = t.exception) == null ? void 0 : e.values) == null ? void 0 : n[0]
            }
            function F(t) {
                const {message: e, event_id: n} = t;
                if (e)
                    return e;
                const r = En(t);
                return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>"
            }
            function Gt(t, e, n) {
                const r = t.exception = t.exception || {}
                  , o = r.values = r.values || []
                  , s = o[0] = o[0] || {};
                s.value || (s.value = e || ""),
                s.type || (s.type = "Error")
            }
            function J(t, e) {
                const n = En(t);
                if (!n)
                    return;
                const r = {
                    type: "generic",
                    handled: !0
                }
                  , o = n.mechanism;
                if (n.mechanism = {
                    ...r,
                    ...o,
                    ...e
                },
                e && "data"in e) {
                    const s = {
                        ...o == null ? void 0 : o.data,
                        ...e.data
                    };
                    n.mechanism.data = s
                }
            }
            function ke(t) {
                if (Fr(t))
                    return !0;
                try {
                    $(t, "__sentry_captured__", !0)
                } catch {}
                return !1
            }
            function Fr(t) {
                try {
                    return t.__sentry_captured__
                } catch {}
            }
            var v;
            (function(t) {
                t[t.PENDING = 0] = "PENDING";
                const n = 1;
                t[t.RESOLVED = n] = "RESOLVED";
                const r = 2;
                t[t.REJECTED = r] = "REJECTED"
            }
            )(v || (v = {}));
            function H(t) {
                return new O(e => {
                    e(t)
                }
                )
            }
            function yt(t) {
                return new O( (e, n) => {
                    n(t)
                }
                )
            }
            class O {
                constructor(e) {
                    this._state = v.PENDING,
                    this._handlers = [],
                    this._runExecutor(e)
                }
                then(e, n) {
                    return new O( (r, o) => {
                        this._handlers.push([!1, s => {
                            if (!e)
                                r(s);
                            else
                                try {
                                    r(e(s))
                                } catch (i) {
                                    o(i)
                                }
                        }
                        , s => {
                            if (!n)
                                o(s);
                            else
                                try {
                                    r(n(s))
                                } catch (i) {
                                    o(i)
                                }
                        }
                        ]),
                        this._executeHandlers()
                    }
                    )
                }
                catch(e) {
                    return this.then(n => n, e)
                }
                finally(e) {
                    return new O( (n, r) => {
                        let o, s;
                        return this.then(i => {
                            s = !1,
                            o = i,
                            e && e()
                        }
                        , i => {
                            s = !0,
                            o = i,
                            e && e()
                        }
                        ).then( () => {
                            if (s) {
                                r(o);
                                return
                            }
                            n(o)
                        }
                        )
                    }
                    )
                }
                _executeHandlers() {
                    if (this._state === v.PENDING)
                        return;
                    const e = this._handlers.slice();
                    this._handlers = [],
                    e.forEach(n => {
                        n[0] || (this._state === v.RESOLVED && n[1](this._value),
                        this._state === v.REJECTED && n[2](this._value),
                        n[0] = !0)
                    }
                    )
                }
                _runExecutor(e) {
                    const n = (s, i) => {
                        if (this._state === v.PENDING) {
                            if (Dt(i)) {
                                i.then(r, o);
                                return
                            }
                            this._state = s,
                            this._value = i,
                            this._executeHandlers()
                        }
                    }
                      , r = s => {
                        n(v.RESOLVED, s)
                    }
                      , o = s => {
                        n(v.REJECTED, s)
                    }
                    ;
                    try {
                        e(r, o)
                    } catch (s) {
                        o(s)
                    }
                }
            }
            function Mr(t) {
                const e = Q()
                  , n = {
                    sid: I(),
                    init: !0,
                    timestamp: e,
                    started: e,
                    duration: 0,
                    status: "ok",
                    errors: 0,
                    ignoreDuration: !1,
                    toJSON: () => Lr(n)
                };
                return t && q(n, t),
                n
            }
            function q(t, e={}) {
                if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address),
                !t.did && !e.did && (t.did = e.user.id || e.user.email || e.user.username)),
                t.timestamp = e.timestamp || Q(),
                e.abnormal_mechanism && (t.abnormal_mechanism = e.abnormal_mechanism),
                e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration),
                e.sid && (t.sid = e.sid.length === 32 ? e.sid : I()),
                e.init !== void 0 && (t.init = e.init),
                !t.did && e.did && (t.did = `${e.did}`),
                typeof e.started == "number" && (t.started = e.started),
                t.ignoreDuration)
                    t.duration = void 0;
                else if (typeof e.duration == "number")
                    t.duration = e.duration;
                else {
                    const n = t.timestamp - t.started;
                    t.duration = n >= 0 ? n : 0
                }
                e.release && (t.release = e.release),
                e.environment && (t.environment = e.environment),
                !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress),
                !t.userAgent && e.userAgent && (t.userAgent = e.userAgent),
                typeof e.errors == "number" && (t.errors = e.errors),
                e.status && (t.status = e.status)
            }
            function Or(t, e) {
                let n = {};
                t.status === "ok" && (n = {
                    status: "exited"
                }),
                q(t, n)
            }
            function Lr(t) {
                return w({
                    sid: `${t.sid}`,
                    init: t.init,
                    started: new Date(t.started * 1e3).toISOString(),
                    timestamp: new Date(t.timestamp * 1e3).toISOString(),
                    status: t.status,
                    errors: t.errors,
                    did: typeof t.did == "number" || typeof t.did == "string" ? `${t.did}` : void 0,
                    duration: t.duration,
                    abnormal_mechanism: t.abnormal_mechanism,
                    attrs: {
                        release: t.release,
                        environment: t.environment,
                        ip_address: t.ipAddress,
                        user_agent: t.userAgent
                    }
                })
            }
            function De() {
                return I()
            }
            function yn() {
                return I().substring(16)
            }
            function it(t, e, n=2) {
                if (!e || typeof e != "object" || n <= 0)
                    return e;
                if (t && Object.keys(e).length === 0)
                    return t;
                const r = {
                    ...t
                };
                for (const o in e)
                    Object.prototype.hasOwnProperty.call(e, o) && (r[o] = it(r[o], e[o], n - 1));
                return r
            }
            const $t = "_sentrySpan";
            function ve(t, e) {
                e ? $(t, $t, e) : delete t[$t]
            }
            function Re(t) {
                return t[$t]
            }
            const Pr = 100;
            class x {
                constructor() {
                    this._notifyingListeners = !1,
                    this._scopeListeners = [],
                    this._eventProcessors = [],
                    this._breadcrumbs = [],
                    this._attachments = [],
                    this._user = {},
                    this._tags = {},
                    this._extra = {},
                    this._contexts = {},
                    this._sdkProcessingMetadata = {},
                    this._propagationContext = {
                        traceId: De(),
                        sampleRand: Math.random()
                    }
                }
                clone() {
                    const e = new x;
                    return e._breadcrumbs = [...this._breadcrumbs],
                    e._tags = {
                        ...this._tags
                    },
                    e._extra = {
                        ...this._extra
                    },
                    e._contexts = {
                        ...this._contexts
                    },
                    this._contexts.flags && (e._contexts.flags = {
                        values: [...this._contexts.flags.values]
                    }),
                    e._user = this._user,
                    e._level = this._level,
                    e._session = this._session,
                    e._transactionName = this._transactionName,
                    e._fingerprint = this._fingerprint,
                    e._eventProcessors = [...this._eventProcessors],
                    e._attachments = [...this._attachments],
                    e._sdkProcessingMetadata = {
                        ...this._sdkProcessingMetadata
                    },
                    e._propagationContext = {
                        ...this._propagationContext
                    },
                    e._client = this._client,
                    e._lastEventId = this._lastEventId,
                    ve(e, Re(this)),
                    e
                }
                setClient(e) {
                    this._client = e
                }
                setLastEventId(e) {
                    this._lastEventId = e
                }
                getClient() {
                    return this._client
                }
                lastEventId() {
                    return this._lastEventId
                }
                addScopeListener(e) {
                    this._scopeListeners.push(e)
                }
                addEventProcessor(e) {
                    return this._eventProcessors.push(e),
                    this
                }
                setUser(e) {
                    return this._user = e || {
                        email: void 0,
                        id: void 0,
                        ip_address: void 0,
                        username: void 0
                    },
                    this._session && q(this._session, {
                        user: e
                    }),
                    this._notifyScopeListeners(),
                    this
                }
                getUser() {
                    return this._user
                }
                setTags(e) {
                    return this._tags = {
                        ...this._tags,
                        ...e
                    },
                    this._notifyScopeListeners(),
                    this
                }
                setTag(e, n) {
                    return this._tags = {
                        ...this._tags,
                        [e]: n
                    },
                    this._notifyScopeListeners(),
                    this
                }
                setExtras(e) {
                    return this._extra = {
                        ...this._extra,
                        ...e
                    },
                    this._notifyScopeListeners(),
                    this
                }
                setExtra(e, n) {
                    return this._extra = {
                        ...this._extra,
                        [e]: n
                    },
                    this._notifyScopeListeners(),
                    this
                }
                setFingerprint(e) {
                    return this._fingerprint = e,
                    this._notifyScopeListeners(),
                    this
                }
                setLevel(e) {
                    return this._level = e,
                    this._notifyScopeListeners(),
                    this
                }
                setTransactionName(e) {
                    return this._transactionName = e,
                    this._notifyScopeListeners(),
                    this
                }
                setContext(e, n) {
                    return n === null ? delete this._contexts[e] : this._contexts[e] = n,
                    this._notifyScopeListeners(),
                    this
                }
                setSession(e) {
                    return e ? this._session = e : delete this._session,
                    this._notifyScopeListeners(),
                    this
                }
                getSession() {
                    return this._session
                }
                update(e) {
                    if (!e)
                        return this;
                    const n = typeof e == "function" ? e(this) : e
                      , r = n instanceof x ? n.getScopeData() : X(n) ? e : void 0
                      , {tags: o, extra: s, user: i, contexts: a, level: c, fingerprint: u=[], propagationContext: l} = r || {};
                    return this._tags = {
                        ...this._tags,
                        ...o
                    },
                    this._extra = {
                        ...this._extra,
                        ...s
                    },
                    this._contexts = {
                        ...this._contexts,
                        ...a
                    },
                    i && Object.keys(i).length && (this._user = i),
                    c && (this._level = c),
                    u.length && (this._fingerprint = u),
                    l && (this._propagationContext = l),
                    this
                }
                clear() {
                    return this._breadcrumbs = [],
                    this._tags = {},
                    this._extra = {},
                    this._user = {},
                    this._contexts = {},
                    this._level = void 0,
                    this._transactionName = void 0,
                    this._fingerprint = void 0,
                    this._session = void 0,
                    ve(this, void 0),
                    this._attachments = [],
                    this.setPropagationContext({
                        traceId: De(),
                        sampleRand: Math.random()
                    }),
                    this._notifyScopeListeners(),
                    this
                }
                addBreadcrumb(e, n) {
                    var s;
                    const r = typeof n == "number" ? n : Pr;
                    if (r <= 0)
                        return this;
                    const o = {
                        timestamp: st(),
                        ...e
                    };
                    return this._breadcrumbs.push(o),
                    this._breadcrumbs.length > r && (this._breadcrumbs = this._breadcrumbs.slice(-r),
                    (s = this._client) == null || s.recordDroppedEvent("buffer_overflow", "log_item")),
                    this._notifyScopeListeners(),
                    this
                }
                getLastBreadcrumb() {
                    return this._breadcrumbs[this._breadcrumbs.length - 1]
                }
                clearBreadcrumbs() {
                    return this._breadcrumbs = [],
                    this._notifyScopeListeners(),
                    this
                }
                addAttachment(e) {
                    return this._attachments.push(e),
                    this
                }
                clearAttachments() {
                    return this._attachments = [],
                    this
                }
                getScopeData() {
                    return {
                        breadcrumbs: this._breadcrumbs,
                        attachments: this._attachments,
                        contexts: this._contexts,
                        tags: this._tags,
                        extra: this._extra,
                        user: this._user,
                        level: this._level,
                        fingerprint: this._fingerprint || [],
                        eventProcessors: this._eventProcessors,
                        propagationContext: this._propagationContext,
                        sdkProcessingMetadata: this._sdkProcessingMetadata,
                        transactionName: this._transactionName,
                        span: Re(this)
                    }
                }
                setSDKProcessingMetadata(e) {
                    return this._sdkProcessingMetadata = it(this._sdkProcessingMetadata, e, 2),
                    this
                }
                setPropagationContext(e) {
                    return this._propagationContext = e,
                    this
                }
                getPropagationContext() {
                    return this._propagationContext
                }
                captureException(e, n) {
                    const r = (n == null ? void 0 : n.event_id) || I();
                    if (!this._client)
                        return p.warn("No client configured on scope - will not capture exception!"),
                        r;
                    const o = new Error("Sentry syntheticException");
                    return this._client.captureException(e, {
                        originalException: e,
                        syntheticException: o,
                        ...n,
                        event_id: r
                    }, this),
                    r
                }
                captureMessage(e, n, r) {
                    const o = (r == null ? void 0 : r.event_id) || I();
                    if (!this._client)
                        return p.warn("No client configured on scope - will not capture message!"),
                        o;
                    const s = new Error(e);
                    return this._client.captureMessage(e, n, {
                        originalException: e,
                        syntheticException: s,
                        ...r,
                        event_id: o
                    }, this),
                    o
                }
                captureEvent(e, n) {
                    const r = (n == null ? void 0 : n.event_id) || I();
                    return this._client ? (this._client.captureEvent(e, {
                        ...n,
                        event_id: r
                    }, this),
                    r) : (p.warn("No client configured on scope - will not capture event!"),
                    r)
                }
                _notifyScopeListeners() {
                    this._notifyingListeners || (this._notifyingListeners = !0,
                    this._scopeListeners.forEach(e => {
                        e(this)
                    }
                    ),
                    this._notifyingListeners = !1)
                }
            }
            function Ur() {
                return Tt("defaultCurrentScope", () => new x)
            }
            function Gr() {
                return Tt("defaultIsolationScope", () => new x)
            }
            class $r {
                constructor(e, n) {
                    let r;
                    e ? r = e : r = new x;
                    let o;
                    n ? o = n : o = new x,
                    this._stack = [{
                        scope: r
                    }],
                    this._isolationScope = o
                }
                withScope(e) {
                    const n = this._pushScope();
                    let r;
                    try {
                        r = e(n)
                    } catch (o) {
                        throw this._popScope(),
                        o
                    }
                    return Dt(r) ? r.then(o => (this._popScope(),
                    o), o => {
                        throw this._popScope(),
                        o
                    }
                    ) : (this._popScope(),
                    r)
                }
                getClient() {
                    return this.getStackTop().client
                }
                getScope() {
                    return this.getStackTop().scope
                }
                getIsolationScope() {
                    return this._isolationScope
                }
                getStackTop() {
                    return this._stack[this._stack.length - 1]
                }
                _pushScope() {
                    const e = this.getScope().clone();
                    return this._stack.push({
                        client: this.getClient(),
                        scope: e
                    }),
                    e
                }
                _popScope() {
                    return this._stack.length <= 1 ? !1 : !!this._stack.pop()
                }
            }
            function K() {
                const t = Bt()
                  , e = It(t);
                return e.stack = e.stack || new $r(Ur(),Gr())
            }
            function Hr(t) {
                return K().withScope(t)
            }
            function jr(t, e) {
                const n = K();
                return n.withScope( () => (n.getStackTop().scope = t,
                e(t)))
            }
            function Ce(t) {
                return K().withScope( () => t(K().getIsolationScope()))
            }
            function Wr() {
                return {
                    withIsolationScope: Ce,
                    withScope: Hr,
                    withSetScope: jr,
                    withSetIsolationScope: (t, e) => Ce(e),
                    getCurrentScope: () => K().getScope(),
                    getIsolationScope: () => K().getIsolationScope()
                }
            }
            function fe(t) {
                const e = It(t);
                return e.acs ? e.acs : Wr()
            }
            function L() {
                const t = Bt();
                return fe(t).getCurrentScope()
            }
            function at() {
                const t = Bt();
                return fe(t).getIsolationScope()
            }
            function Yr() {
                return Tt("globalScope", () => new x)
            }
            function Vr(...t) {
                const e = Bt()
                  , n = fe(e);
                if (t.length === 2) {
                    const [r,o] = t;
                    return r ? n.withSetScope(r, o) : n.withScope(o)
                }
                return n.withScope(t[0])
            }
            function A() {
                return L().getClient()
            }
            function zr(t) {
                const e = t.getPropagationContext()
                  , {traceId: n, parentSpanId: r, propagationSpanId: o} = e;
                return w({
                    trace_id: n,
                    span_id: o || yn(),
                    parent_span_id: r
                })
            }
            const Xr = "sentry.source"
              , Jr = "sentry.sample_rate"
              , qr = "sentry.op"
              , Kr = "sentry.origin"
              , An = "sentry.profile_id"
              , Sn = "sentry.exclusive_time"
              , Zr = 0
              , to = 1
              , eo = "_sentryScope"
              , no = "_sentryIsolationScope";
            function bn(t) {
                return {
                    scope: t[eo],
                    isolationScope: t[no]
                }
            }
            function ro(t) {
                if (typeof t == "boolean")
                    return Number(t);
                const e = typeof t == "string" ? parseFloat(t) : t;
                if (!(typeof e != "number" || isNaN(e) || e < 0 || e > 1))
                    return e
            }
            const oo = "sentry-"
              , so = /^sentry-/;
            function io(t) {
                const e = ao(t);
                if (!e)
                    return;
                const n = Object.entries(e).reduce( (r, [o,s]) => {
                    if (o.match(so)) {
                        const i = o.slice(oo.length);
                        r[i] = s
                    }
                    return r
                }
                , {});
                if (Object.keys(n).length > 0)
                    return n
            }
            function ao(t) {
                if (!(!t || !N(t) && !Array.isArray(t)))
                    return Array.isArray(t) ? t.reduce( (e, n) => {
                        const r = Ne(n);
                        return Object.entries(r).forEach( ([o,s]) => {
                            e[o] = s
                        }
                        ),
                        e
                    }
                    , {}) : Ne(t)
            }
            function Ne(t) {
                return t.split(",").map(e => e.split("=").map(n => decodeURIComponent(n.trim()))).reduce( (e, [n,r]) => (n && r && (e[n] = r),
                e), {})
            }
            const wn = 1;
            let Qe = !1;
            function co(t) {
                const {spanId: e, traceId: n, isRemote: r} = t.spanContext()
                  , o = r ? e : le(t).parent_span_id
                  , s = bn(t).scope
                  , i = r ? (s == null ? void 0 : s.getPropagationContext().propagationSpanId) || yn() : e;
                return w({
                    parent_span_id: o,
                    span_id: i,
                    trace_id: n
                })
            }
            function uo(t) {
                if (t && t.length > 0)
                    return t.map( ({context: {spanId: e, traceId: n, traceFlags: r, ...o}, attributes: s}) => ({
                        span_id: e,
                        trace_id: n,
                        sampled: r === wn,
                        attributes: s,
                        ...o
                    }))
            }
            function xe(t) {
                return typeof t == "number" ? Fe(t) : Array.isArray(t) ? t[0] + t[1] / 1e9 : t instanceof Date ? Fe(t.getTime()) : Q()
            }
            function Fe(t) {
                return t > 9999999999 ? t / 1e3 : t
            }
            function le(t) {
                if (lo(t))
                    return t.getSpanJSON();
                const {spanId: e, traceId: n} = t.spanContext();
                if (fo(t)) {
                    const {attributes: r, startTime: o, name: s, endTime: i, parentSpanId: a, status: c, links: u} = t;
                    return w({
                        span_id: e,
                        trace_id: n,
                        data: r,
                        description: s,
                        parent_span_id: a,
                        start_timestamp: xe(o),
                        timestamp: xe(i) || void 0,
                        status: go(c),
                        op: r[qr],
                        origin: r[Kr],
                        links: uo(u)
                    })
                }
                return {
                    span_id: e,
                    trace_id: n,
                    start_timestamp: 0,
                    data: {}
                }
            }
            function fo(t) {
                const e = t;
                return !!e.attributes && !!e.startTime && !!e.name && !!e.endTime && !!e.status
            }
            function lo(t) {
                return typeof t.getSpanJSON == "function"
            }
            function po(t) {
                const {traceFlags: e} = t.spanContext();
                return e === wn
            }
            function go(t) {
                if (!(!t || t.code === Zr))
                    return t.code === to ? "ok" : t.message || "unknown_error"
            }
            const ho = "_sentryRootSpan";
            function Bn(t) {
                return t[ho] || t
            }
            function Me() {
                Qe || (tt( () => {
                    console.warn("[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly.")
                }
                ),
                Qe = !0)
            }
            function mo(t) {
                var n;
                if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__)
                    return !1;
                const e = t || ((n = A()) == null ? void 0 : n.getOptions());
                return !!e && (e.tracesSampleRate != null || !!e.tracesSampler)
            }
            const de = "production"
              , _o = "_frozenDsc";
            function In(t, e) {
                const n = e.getOptions()
                  , {publicKey: r} = e.getDsn() || {}
                  , o = w({
                    environment: n.environment || de,
                    release: n.release,
                    public_key: r,
                    trace_id: t
                });
                return e.emit("createDsc", o),
                o
            }
            function Eo(t, e) {
                const n = e.getPropagationContext();
                return n.dsc || In(n.traceId, t)
            }
            function yo(t) {
                var E;
                const e = A();
                if (!e)
                    return {};
                const n = Bn(t)
                  , r = le(n)
                  , o = r.data
                  , s = n.spanContext().traceState
                  , i = (s == null ? void 0 : s.get("sentry.sample_rate")) ?? o[Jr];
                function a(B) {
                    return (typeof i == "number" || typeof i == "string") && (B.sample_rate = `${i}`),
                    B
                }
                const c = n[_o];
                if (c)
                    return a(c);
                const u = s == null ? void 0 : s.get("sentry.dsc")
                  , l = u && io(u);
                if (l)
                    return a(l);
                const f = In(t.spanContext().traceId, e)
                  , g = o[Xr]
                  , d = r.description;
                return g !== "url" && d && (f.transaction = d),
                mo() && (f.sampled = String(po(n)),
                f.sample_rand = (s == null ? void 0 : s.get("sentry.sample_rand")) ?? ((E = bn(n).scope) == null ? void 0 : E.getPropagationContext().sampleRand.toString())),
                a(f),
                e.emit("createDsc", f, n),
                f
            }
            const Ao = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
            function So(t) {
                return t === "http" || t === "https"
            }
            function pe(t, e=!1) {
                const {host: n, path: r, pass: o, port: s, projectId: i, protocol: a, publicKey: c} = t;
                return `${a}://${c}${e && o ? `:${o}` : ""}@${n}${s ? `:${s}` : ""}/${r && `${r}/`}${i}`
            }
            function bo(t) {
                const e = Ao.exec(t);
                if (!e) {
                    tt( () => {
                        console.error(`Invalid Sentry Dsn: ${t}`)
                    }
                    );
                    return
                }
                const [n,r,o="",s="",i="",a=""] = e.slice(1);
                let c = ""
                  , u = a;
                const l = u.split("/");
                if (l.length > 1 && (c = l.slice(0, -1).join("/"),
                u = l.pop()),
                u) {
                    const f = u.match(/^\d+/);
                    f && (u = f[0])
                }
                return Tn({
                    host: s,
                    pass: o,
                    path: c,
                    projectId: u,
                    port: i,
                    protocol: n,
                    publicKey: r
                })
            }
            function Tn(t) {
                return {
                    protocol: t.protocol,
                    publicKey: t.publicKey || "",
                    pass: t.pass || "",
                    host: t.host,
                    port: t.port || "",
                    path: t.path || "",
                    projectId: t.projectId
                }
            }
            function wo(t) {
                if (!W)
                    return !0;
                const {port: e, projectId: n, protocol: r} = t;
                return ["protocol", "publicKey", "host", "projectId"].find(i => t[i] ? !1 : (p.error(`Invalid Sentry Dsn: ${i} missing`),
                !0)) ? !1 : n.match(/^\d+$/) ? So(r) ? e && isNaN(parseInt(e, 10)) ? (p.error(`Invalid Sentry Dsn: Invalid port ${e}`),
                !1) : !0 : (p.error(`Invalid Sentry Dsn: Invalid protocol ${r}`),
                !1) : (p.error(`Invalid Sentry Dsn: Invalid projectId ${n}`),
                !1)
            }
            function Bo(t) {
                const e = typeof t == "string" ? bo(t) : Tn(t);
                if (!(!e || !wo(e)))
                    return e
            }
            function R(t, e=100, n=1 / 0) {
                try {
                    return Ht("", t, e, n)
                } catch (r) {
                    return {
                        ERROR: `**non-serializable** (${r})`
                    }
                }
            }
            function kn(t, e=3, n=100 * 1024) {
                const r = R(t, e);
                return Do(r) > n ? kn(t, e - 1, n) : r
            }
            function Ht(t, e, n=1 / 0, r=1 / 0, o=vo()) {
                const [s,i] = o;
                if (e == null || ["boolean", "string"].includes(typeof e) || typeof e == "number" && Number.isFinite(e))
                    return e;
                const a = Io(t, e);
                if (!a.startsWith("[object "))
                    return a;
                if (e.__sentry_skip_normalization__)
                    return e;
                const c = typeof e.__sentry_override_normalization_depth__ == "number" ? e.__sentry_override_normalization_depth__ : n;
                if (c === 0)
                    return a.replace("object ", "");
                if (s(e))
                    return "[Circular ~]";
                const u = e;
                if (u && typeof u.toJSON == "function")
                    try {
                        const d = u.toJSON();
                        return Ht("", d, c - 1, r, o)
                    } catch {}
                const l = Array.isArray(e) ? [] : {};
                let f = 0;
                const g = mn(e);
                for (const d in g) {
                    if (!Object.prototype.hasOwnProperty.call(g, d))
                        continue;
                    if (f >= r) {
                        l[d] = "[MaxProperties ~]";
                        break
                    }
                    const E = g[d];
                    l[d] = Ht(d, E, c - 1, r, o),
                    f++
                }
                return i(e),
                l
            }
            function Io(t, e) {
                try {
                    if (t === "domain" && e && typeof e == "object" && e._events)
                        return "[Domain]";
                    if (t === "domainEmitter")
                        return "[DomainEmitter]";
                    if (typeof global < "u" && e === global)
                        return "[Global]";
                    if (typeof window < "u" && e === window)
                        return "[Window]";
                    if (typeof document < "u" && e === document)
                        return "[Document]";
                    if (pn(e))
                        return "[VueViewModel]";
                    if (Tr(e))
                        return "[SyntheticEvent]";
                    if (typeof e == "number" && !Number.isFinite(e))
                        return `[${e}]`;
                    if (typeof e == "function")
                        return `[Function: ${M(e)}]`;
                    if (typeof e == "symbol")
                        return `[${String(e)}]`;
                    if (typeof e == "bigint")
                        return `[BigInt: ${String(e)}]`;
                    const n = To(e);
                    return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`
                } catch (n) {
                    return `**non-serializable** (${n})`
                }
            }
            function To(t) {
                const e = Object.getPrototypeOf(t);
                return e != null && e.constructor ? e.constructor.name : "null prototype"
            }
            function ko(t) {
                return ~-encodeURI(t).split(/%..|./).length
            }
            function Do(t) {
                return ko(JSON.stringify(t))
            }
            function vo() {
                const t = new WeakSet;
                function e(r) {
                    return t.has(r) ? !0 : (t.add(r),
                    !1)
                }
                function n(r) {
                    t.delete(r)
                }
                return [e, n]
            }
            function Rt(t, e=[]) {
                return [t, e]
            }
            function Ro(t, e) {
                const [n,r] = t;
                return [n, [...r, e]]
            }
            function Oe(t, e) {
                const n = t[1];
                for (const r of n) {
                    const o = r[0].type;
                    if (e(r, o))
                        return !0
                }
                return !1
            }
            function jt(t) {
                const e = It(m);
                return e.encodePolyfill ? e.encodePolyfill(t) : new TextEncoder().encode(t)
            }
            function Co(t) {
                const [e,n] = t;
                let r = JSON.stringify(e);
                function o(s) {
                    typeof r == "string" ? r = typeof s == "string" ? r + s : [jt(r), s] : r.push(typeof s == "string" ? jt(s) : s)
                }
                for (const s of n) {
                    const [i,a] = s;
                    if (o(`
${JSON.stringify(i)}
`),
                    typeof a == "string" || a instanceof Uint8Array)
                        o(a);
                    else {
                        let c;
                        try {
                            c = JSON.stringify(a)
                        } catch {
                            c = JSON.stringify(R(a))
                        }
                        o(c)
                    }
                }
                return typeof r == "string" ? r : No(r)
            }
            function No(t) {
                const e = t.reduce( (o, s) => o + s.length, 0)
                  , n = new Uint8Array(e);
                let r = 0;
                for (const o of t)
                    n.set(o, r),
                    r += o.length;
                return n
            }
            function Qo(t) {
                const e = typeof t.data == "string" ? jt(t.data) : t.data;
                return [w({
                    type: "attachment",
                    length: e.length,
                    filename: t.filename,
                    content_type: t.contentType,
                    attachment_type: t.attachmentType
                }), e]
            }
            const xo = {
                session: "session",
                sessions: "session",
                attachment: "attachment",
                transaction: "transaction",
                event: "error",
                client_report: "internal",
                user_report: "default",
                profile: "profile",
                profile_chunk: "profile",
                replay_event: "replay",
                replay_recording: "replay",
                check_in: "monitor",
                feedback: "feedback",
                span: "span",
                raw_security: "security",
                otel_log: "log_item"
            };
            function Le(t) {
                return xo[t]
            }
            function Dn(t) {
                if (!(t != null && t.sdk))
                    return;
                const {name: e, version: n} = t.sdk;
                return {
                    name: e,
                    version: n
                }
            }
            function Fo(t, e, n, r) {
                var s;
                const o = (s = t.sdkProcessingMetadata) == null ? void 0 : s.dynamicSamplingContext;
                return {
                    event_id: t.event_id,
                    sent_at: new Date().toISOString(),
                    ...e && {
                        sdk: e
                    },
                    ...!!n && r && {
                        dsn: pe(r)
                    },
                    ...o && {
                        trace: w({
                            ...o
                        })
                    }
                }
            }
            function Mo(t, e) {
                return e && (t.sdk = t.sdk || {},
                t.sdk.name = t.sdk.name || e.name,
                t.sdk.version = t.sdk.version || e.version,
                t.sdk.integrations = [...t.sdk.integrations || [], ...e.integrations || []],
                t.sdk.packages = [...t.sdk.packages || [], ...e.packages || []]),
                t
            }
            function Oo(t, e, n, r) {
                const o = Dn(n)
                  , s = {
                    sent_at: new Date().toISOString(),
                    ...o && {
                        sdk: o
                    },
                    ...!!r && e && {
                        dsn: pe(e)
                    }
                }
                  , i = "aggregates"in t ? [{
                    type: "sessions"
                }, t] : [{
                    type: "session"
                }, t.toJSON()];
                return Rt(s, [i])
            }
            function Lo(t, e, n, r) {
                const o = Dn(n)
                  , s = t.type && t.type !== "replay_event" ? t.type : "event";
                Mo(t, n == null ? void 0 : n.sdk);
                const i = Fo(t, o, r, e);
                return delete t.sdkProcessingMetadata,
                Rt(i, [[{
                    type: s
                }, t]])
            }
            function Wt(t, e, n, r=0) {
                return new O( (o, s) => {
                    const i = t[r];
                    if (e === null || typeof i != "function")
                        o(e);
                    else {
                        const a = i({
                            ...e
                        }, n);
                        h && i.id && a === null && p.log(`Event processor "${i.id}" dropped event`),
                        Dt(a) ? a.then(c => Wt(t, c, n, r + 1).then(o)).then(null, s) : Wt(t, a, n, r + 1).then(o).then(null, s)
                    }
                }
                )
            }
            let ft, Pe, lt;
            function Po(t) {
                const e = m._sentryDebugIds;
                if (!e)
                    return {};
                const n = Object.keys(e);
                return lt && n.length === Pe || (Pe = n.length,
                lt = n.reduce( (r, o) => {
                    ft || (ft = {});
                    const s = ft[o];
                    if (s)
                        r[s[0]] = s[1];
                    else {
                        const i = t(o);
                        for (let a = i.length - 1; a >= 0; a--) {
                            const c = i[a]
                              , u = c == null ? void 0 : c.filename
                              , l = e[o];
                            if (u && l) {
                                r[u] = l,
                                ft[o] = [u, l];
                                break
                            }
                        }
                    }
                    return r
                }
                , {})),
                lt
            }
            function Uo(t, e) {
                const {fingerprint: n, span: r, breadcrumbs: o, sdkProcessingMetadata: s} = e;
                Go(t, e),
                r && jo(t, r),
                Wo(t, n),
                $o(t, o),
                Ho(t, s)
            }
            function Ue(t, e) {
                const {extra: n, tags: r, user: o, contexts: s, level: i, sdkProcessingMetadata: a, breadcrumbs: c, fingerprint: u, eventProcessors: l, attachments: f, propagationContext: g, transactionName: d, span: E} = e;
                dt(t, "extra", n),
                dt(t, "tags", r),
                dt(t, "user", o),
                dt(t, "contexts", s),
                t.sdkProcessingMetadata = it(t.sdkProcessingMetadata, a, 2),
                i && (t.level = i),
                d && (t.transactionName = d),
                E && (t.span = E),
                c.length && (t.breadcrumbs = [...t.breadcrumbs, ...c]),
                u.length && (t.fingerprint = [...t.fingerprint, ...u]),
                l.length && (t.eventProcessors = [...t.eventProcessors, ...l]),
                f.length && (t.attachments = [...t.attachments, ...f]),
                t.propagationContext = {
                    ...t.propagationContext,
                    ...g
                }
            }
            function dt(t, e, n) {
                t[e] = it(t[e], n, 1)
            }
            function Go(t, e) {
                const {extra: n, tags: r, user: o, contexts: s, level: i, transactionName: a} = e
                  , c = w(n);
                Object.keys(c).length && (t.extra = {
                    ...c,
                    ...t.extra
                });
                const u = w(r);
                Object.keys(u).length && (t.tags = {
                    ...u,
                    ...t.tags
                });
                const l = w(o);
                Object.keys(l).length && (t.user = {
                    ...l,
                    ...t.user
                });
                const f = w(s);
                Object.keys(f).length && (t.contexts = {
                    ...f,
                    ...t.contexts
                }),
                i && (t.level = i),
                a && t.type !== "transaction" && (t.transaction = a)
            }
            function $o(t, e) {
                const n = [...t.breadcrumbs || [], ...e];
                t.breadcrumbs = n.length ? n : void 0
            }
            function Ho(t, e) {
                t.sdkProcessingMetadata = {
                    ...t.sdkProcessingMetadata,
                    ...e
                }
            }
            function jo(t, e) {
                t.contexts = {
                    trace: co(e),
                    ...t.contexts
                },
                t.sdkProcessingMetadata = {
                    dynamicSamplingContext: yo(e),
                    ...t.sdkProcessingMetadata
                };
                const n = Bn(e)
                  , r = le(n).description;
                r && !t.transaction && t.type === "transaction" && (t.transaction = r)
            }
            function Wo(t, e) {
                t.fingerprint = t.fingerprint ? Array.isArray(t.fingerprint) ? t.fingerprint : [t.fingerprint] : [],
                e && (t.fingerprint = t.fingerprint.concat(e)),
                t.fingerprint.length || delete t.fingerprint
            }
            function Yo(t, e, n, r, o, s) {
                const {normalizeDepth: i=3, normalizeMaxBreadth: a=1e3} = t
                  , c = {
                    ...e,
                    event_id: e.event_id || n.event_id || I(),
                    timestamp: e.timestamp || st()
                }
                  , u = n.integrations || t.integrations.map(y => y.name);
                Vo(c, t),
                Jo(c, u),
                o && o.emit("applyFrameMetadata", e),
                e.type === void 0 && zo(c, t.stackParser);
                const l = Ko(r, n.captureContext);
                n.mechanism && J(c, n.mechanism);
                const f = o ? o.getEventProcessors() : []
                  , g = Yr().getScopeData();
                if (s) {
                    const y = s.getScopeData();
                    Ue(g, y)
                }
                if (l) {
                    const y = l.getScopeData();
                    Ue(g, y)
                }
                const d = [...n.attachments || [], ...g.attachments];
                d.length && (n.attachments = d),
                Uo(c, g);
                const E = [...f, ...g.eventProcessors];
                return Wt(E, c, n).then(y => (y && Xo(y),
                typeof i == "number" && i > 0 ? qo(y, i, a) : y))
            }
            function Vo(t, e) {
                var c, u;
                const {environment: n, release: r, dist: o, maxValueLength: s=250} = e;
                t.environment = t.environment || n || de,
                !t.release && r && (t.release = r),
                !t.dist && o && (t.dist = o),
                t.message && (t.message = z(t.message, s));
                const i = (u = (c = t.exception) == null ? void 0 : c.values) == null ? void 0 : u[0];
                i != null && i.value && (i.value = z(i.value, s));
                const a = t.request;
                a != null && a.url && (a.url = z(a.url, s))
            }
            function zo(t, e) {
                var r, o;
                const n = Po(e);
                (o = (r = t.exception) == null ? void 0 : r.values) == null || o.forEach(s => {
                    var i, a;
                    (a = (i = s.stacktrace) == null ? void 0 : i.frames) == null || a.forEach(c => {
                        c.filename && (c.debug_id = n[c.filename])
                    }
                    )
                }
                )
            }
            function Xo(t) {
                var r, o;
                const e = {};
                if ((o = (r = t.exception) == null ? void 0 : r.values) == null || o.forEach(s => {
                    var i, a;
                    (a = (i = s.stacktrace) == null ? void 0 : i.frames) == null || a.forEach(c => {
                        c.debug_id && (c.abs_path ? e[c.abs_path] = c.debug_id : c.filename && (e[c.filename] = c.debug_id),
                        delete c.debug_id)
                    }
                    )
                }
                ),
                Object.keys(e).length === 0)
                    return;
                t.debug_meta = t.debug_meta || {},
                t.debug_meta.images = t.debug_meta.images || [];
                const n = t.debug_meta.images;
                Object.entries(e).forEach( ([s,i]) => {
                    n.push({
                        type: "sourcemap",
                        code_file: s,
                        debug_id: i
                    })
                }
                )
            }
            function Jo(t, e) {
                e.length > 0 && (t.sdk = t.sdk || {},
                t.sdk.integrations = [...t.sdk.integrations || [], ...e])
            }
            function qo(t, e, n) {
                var o, s;
                if (!t)
                    return null;
                const r = {
                    ...t,
                    ...t.breadcrumbs && {
                        breadcrumbs: t.breadcrumbs.map(i => ({
                            ...i,
                            ...i.data && {
                                data: R(i.data, e, n)
                            }
                        }))
                    },
                    ...t.user && {
                        user: R(t.user, e, n)
                    },
                    ...t.contexts && {
                        contexts: R(t.contexts, e, n)
                    },
                    ...t.extra && {
                        extra: R(t.extra, e, n)
                    }
                };
                return (o = t.contexts) != null && o.trace && r.contexts && (r.contexts.trace = t.contexts.trace,
                t.contexts.trace.data && (r.contexts.trace.data = R(t.contexts.trace.data, e, n))),
                t.spans && (r.spans = t.spans.map(i => ({
                    ...i,
                    ...i.data && {
                        data: R(i.data, e, n)
                    }
                }))),
                (s = t.contexts) != null && s.flags && r.contexts && (r.contexts.flags = R(t.contexts.flags, 3, n)),
                r
            }
            function Ko(t, e) {
                if (!e)
                    return t;
                const n = t ? t.clone() : new x;
                return n.update(e),
                n
            }
            function Zo(t, e) {
                return L().captureException(t, void 0)
            }
            function vn(t, e) {
                return L().captureEvent(t, e)
            }
            function Ge(t) {
                const e = at()
                  , n = L()
                  , {userAgent: r} = m.navigator || {}
                  , o = Mr({
                    user: n.getUser() || e.getUser(),
                    ...r && {
                        userAgent: r
                    },
                    ...t
                })
                  , s = e.getSession();
                return (s == null ? void 0 : s.status) === "ok" && q(s, {
                    status: "exited"
                }),
                Rn(),
                e.setSession(o),
                o
            }
            function Rn() {
                const t = at()
                  , n = L().getSession() || t.getSession();
                n && Or(n),
                Cn(),
                t.setSession()
            }
            function Cn() {
                const t = at()
                  , e = A()
                  , n = t.getSession();
                n && e && e.captureSession(n)
            }
            function $e(t=!1) {
                if (t) {
                    Rn();
                    return
                }
                Cn()
            }
            const ts = "7";
            function es(t) {
                const e = t.protocol ? `${t.protocol}:` : ""
                  , n = t.port ? `:${t.port}` : "";
                return `${e}//${t.host}${n}${t.path ? `/${t.path}` : ""}/api/`
            }
            function ns(t) {
                return `${es(t)}${t.projectId}/envelope/`
            }
            function rs(t, e) {
                const n = {
                    sentry_version: ts
                };
                return t.publicKey && (n.sentry_key = t.publicKey),
                e && (n.sentry_client = `${e.name}/${e.version}`),
                new URLSearchParams(n).toString()
            }
            function os(t, e, n) {
                return e || `${ns(t)}?${rs(t, n)}`
            }
            const He = [];
            function ss(t) {
                const e = {};
                return t.forEach(n => {
                    const {name: r} = n
                      , o = e[r];
                    o && !o.isDefaultInstance && n.isDefaultInstance || (e[r] = n)
                }
                ),
                Object.values(e)
            }
            function is(t) {
                const e = t.defaultIntegrations || []
                  , n = t.integrations;
                e.forEach(o => {
                    o.isDefaultInstance = !0
                }
                );
                let r;
                if (Array.isArray(n))
                    r = [...e, ...n];
                else if (typeof n == "function") {
                    const o = n(e);
                    r = Array.isArray(o) ? o : [o]
                } else
                    r = e;
                return ss(r)
            }
            function as(t, e) {
                const n = {};
                return e.forEach(r => {
                    r && Nn(t, r, n)
                }
                ),
                n
            }
            function je(t, e) {
                for (const n of e)
                    n != null && n.afterAllSetup && n.afterAllSetup(t)
            }
            function Nn(t, e, n) {
                if (n[e.name]) {
                    h && p.log(`Integration skipped because it was already installed: ${e.name}`);
                    return
                }
                if (n[e.name] = e,
                He.indexOf(e.name) === -1 && typeof e.setupOnce == "function" && (e.setupOnce(),
                He.push(e.name)),
                e.setup && typeof e.setup == "function" && e.setup(t),
                typeof e.preprocessEvent == "function") {
                    const r = e.preprocessEvent.bind(e);
                    t.on("preprocessEvent", (o, s) => r(o, s, t))
                }
                if (typeof e.processEvent == "function") {
                    const r = e.processEvent.bind(e)
                      , o = Object.assign( (s, i) => r(s, i, t), {
                        id: e.name
                    });
                    t.addEventProcessor(o)
                }
                h && p.log(`Integration installed: ${e.name}`)
            }
            function cs(t, e, n) {
                const r = [{
                    type: "client_report"
                }, {
                    timestamp: st(),
                    discarded_events: t
                }];
                return Rt(e ? {
                    dsn: e
                } : {}, [r])
            }
            class T extends Error {
                constructor(e, n="warn") {
                    super(e),
                    this.message = e,
                    this.logLevel = n
                }
            }
            function Qn(t) {
                const e = [];
                t.message && e.push(t.message);
                try {
                    const n = t.exception.values[t.exception.values.length - 1];
                    n != null && n.value && (e.push(n.value),
                    n.type && e.push(`${n.type}: ${n.value}`))
                } catch {}
                return e
            }
            function us(t) {
                var c;
                const {trace_id: e, parent_span_id: n, span_id: r, status: o, origin: s, data: i, op: a} = ((c = t.contexts) == null ? void 0 : c.trace) ?? {};
                return w({
                    data: i ?? {},
                    description: t.transaction,
                    op: a,
                    parent_span_id: n,
                    span_id: r ?? "",
                    start_timestamp: t.start_timestamp ?? 0,
                    status: o,
                    timestamp: t.timestamp,
                    trace_id: e ?? "",
                    origin: s,
                    profile_id: i == null ? void 0 : i[An],
                    exclusive_time: i == null ? void 0 : i[Sn],
                    measurements: t.measurements,
                    is_segment: !0
                })
            }
            function fs(t) {
                const e = {
                    type: "transaction",
                    timestamp: t.timestamp,
                    start_timestamp: t.start_timestamp,
                    transaction: t.description,
                    contexts: {
                        trace: {
                            trace_id: t.trace_id,
                            span_id: t.span_id,
                            parent_span_id: t.parent_span_id,
                            op: t.op,
                            status: t.status,
                            origin: t.origin,
                            data: {
                                ...t.data,
                                ...t.profile_id && {
                                    [An]: t.profile_id
                                },
                                ...t.exclusive_time && {
                                    [Sn]: t.exclusive_time
                                }
                            }
                        }
                    },
                    measurements: t.measurements
                };
                return w(e)
            }
            const We = "Not capturing exception because it's already been captured."
              , Ye = "Discarded session because of missing or non-string release";
            class ls {
                constructor(e) {
                    if (this._options = e,
                    this._integrations = {},
                    this._numProcessing = 0,
                    this._outcomes = {},
                    this._hooks = {},
                    this._eventProcessors = [],
                    e.dsn ? this._dsn = Bo(e.dsn) : h && p.warn("No DSN provided, client will not send events."),
                    this._dsn) {
                        const n = os(this._dsn, e.tunnel, e._metadata ? e._metadata.sdk : void 0);
                        this._transport = e.transport({
                            tunnel: this._options.tunnel,
                            recordDroppedEvent: this.recordDroppedEvent.bind(this),
                            ...e.transportOptions,
                            url: n
                        })
                    }
                }
                captureException(e, n, r) {
                    const o = I();
                    if (ke(e))
                        return h && p.log(We),
                        o;
                    const s = {
                        event_id: o,
                        ...n
                    };
                    return this._process(this.eventFromException(e, s).then(i => this._captureEvent(i, s, r))),
                    s.event_id
                }
                captureMessage(e, n, r, o) {
                    const s = {
                        event_id: I(),
                        ...r
                    }
                      , i = se(e) ? e : String(e)
                      , a = ie(e) ? this.eventFromMessage(i, n, s) : this.eventFromException(e, s);
                    return this._process(a.then(c => this._captureEvent(c, s, o))),
                    s.event_id
                }
                captureEvent(e, n, r) {
                    const o = I();
                    if (n != null && n.originalException && ke(n.originalException))
                        return h && p.log(We),
                        o;
                    const s = {
                        event_id: o,
                        ...n
                    }
                      , i = e.sdkProcessingMetadata || {}
                      , a = i.capturedSpanScope
                      , c = i.capturedSpanIsolationScope;
                    return this._process(this._captureEvent(e, s, a || r, c)),
                    s.event_id
                }
                captureSession(e) {
                    this.sendSession(e),
                    q(e, {
                        init: !1
                    })
                }
                getDsn() {
                    return this._dsn
                }
                getOptions() {
                    return this._options
                }
                getSdkMetadata() {
                    return this._options._metadata
                }
                getTransport() {
                    return this._transport
                }
                flush(e) {
                    const n = this._transport;
                    return n ? (this.emit("flush"),
                    this._isClientDoneProcessing(e).then(r => n.flush(e).then(o => r && o))) : H(!0)
                }
                close(e) {
                    return this.flush(e).then(n => (this.getOptions().enabled = !1,
                    this.emit("close"),
                    n))
                }
                getEventProcessors() {
                    return this._eventProcessors
                }
                addEventProcessor(e) {
                    this._eventProcessors.push(e)
                }
                init() {
                    (this._isEnabled() || this._options.integrations.some( ({name: e}) => e.startsWith("Spotlight"))) && this._setupIntegrations()
                }
                getIntegrationByName(e) {
                    return this._integrations[e]
                }
                addIntegration(e) {
                    const n = this._integrations[e.name];
                    Nn(this, e, this._integrations),
                    n || je(this, [e])
                }
                sendEvent(e, n={}) {
                    this.emit("beforeSendEvent", e, n);
                    let r = Lo(e, this._dsn, this._options._metadata, this._options.tunnel);
                    for (const s of n.attachments || [])
                        r = Ro(r, Qo(s));
                    const o = this.sendEnvelope(r);
                    o && o.then(s => this.emit("afterSendEvent", e, s), null)
                }
                sendSession(e) {
                    const {release: n, environment: r=de} = this._options;
                    if ("aggregates"in e) {
                        const s = e.attrs || {};
                        if (!s.release && !n) {
                            h && p.warn(Ye);
                            return
                        }
                        s.release = s.release || n,
                        s.environment = s.environment || r,
                        e.attrs = s
                    } else {
                        if (!e.release && !n) {
                            h && p.warn(Ye);
                            return
                        }
                        e.release = e.release || n,
                        e.environment = e.environment || r
                    }
                    this.emit("beforeSendSession", e);
                    const o = Oo(e, this._dsn, this._options._metadata, this._options.tunnel);
                    this.sendEnvelope(o)
                }
                recordDroppedEvent(e, n, r=1) {
                    if (this._options.sendClientReports) {
                        const o = `${e}:${n}`;
                        h && p.log(`Recording outcome: "${o}"${r > 1 ? ` (${r} times)` : ""}`),
                        this._outcomes[o] = (this._outcomes[o] || 0) + r
                    }
                }
                on(e, n) {
                    const r = this._hooks[e] = this._hooks[e] || [];
                    return r.push(n),
                    () => {
                        const o = r.indexOf(n);
                        o > -1 && r.splice(o, 1)
                    }
                }
                emit(e, ...n) {
                    const r = this._hooks[e];
                    r && r.forEach(o => o(...n))
                }
                sendEnvelope(e) {
                    return this.emit("beforeEnvelope", e),
                    this._isEnabled() && this._transport ? this._transport.send(e).then(null, n => (h && p.error("Error while sending envelope:", n),
                    n)) : (h && p.error("Transport disabled"),
                    H({}))
                }
                _setupIntegrations() {
                    const {integrations: e} = this._options;
                    this._integrations = as(this, e),
                    je(this, e)
                }
                _updateSessionFromEvent(e, n) {
                    var c;
                    let r = n.level === "fatal"
                      , o = !1;
                    const s = (c = n.exception) == null ? void 0 : c.values;
                    if (s) {
                        o = !0;
                        for (const u of s) {
                            const l = u.mechanism;
                            if ((l == null ? void 0 : l.handled) === !1) {
                                r = !0;
                                break
                            }
                        }
                    }
                    const i = e.status === "ok";
                    (i && e.errors === 0 || i && r) && (q(e, {
                        ...r && {
                            status: "crashed"
                        },
                        errors: e.errors || Number(o || r)
                    }),
                    this.captureSession(e))
                }
                _isClientDoneProcessing(e) {
                    return new O(n => {
                        let r = 0;
                        const o = 1
                          , s = setInterval( () => {
                            this._numProcessing == 0 ? (clearInterval(s),
                            n(!0)) : (r += o,
                            e && r >= e && (clearInterval(s),
                            n(!1)))
                        }
                        , o)
                    }
                    )
                }
                _isEnabled() {
                    return this.getOptions().enabled !== !1 && this._transport !== void 0
                }
                _prepareEvent(e, n, r, o) {
                    const s = this.getOptions()
                      , i = Object.keys(this._integrations);
                    return !n.integrations && (i != null && i.length) && (n.integrations = i),
                    this.emit("preprocessEvent", e, n),
                    e.type || o.setLastEventId(e.event_id || n.event_id),
                    Yo(s, e, n, r, this, o).then(a => {
                        if (a === null)
                            return a;
                        this.emit("postprocessEvent", a, n),
                        a.contexts = {
                            trace: zr(r),
                            ...a.contexts
                        };
                        const c = Eo(this, r);
                        return a.sdkProcessingMetadata = {
                            dynamicSamplingContext: c,
                            ...a.sdkProcessingMetadata
                        },
                        a
                    }
                    )
                }
                _captureEvent(e, n={}, r=L(), o=at()) {
                    return h && Yt(e) && p.log(`Captured error event \`${Qn(e)[0] || "<unknown>"}\``),
                    this._processEvent(e, n, r, o).then(s => s.event_id, s => {
                        h && (s instanceof T && s.logLevel === "log" ? p.log(s.message) : p.warn(s))
                    }
                    )
                }
                _processEvent(e, n, r, o) {
                    const s = this.getOptions()
                      , {sampleRate: i} = s
                      , a = xn(e)
                      , c = Yt(e)
                      , u = e.type || "error"
                      , l = `before send for type \`${u}\``
                      , f = typeof i > "u" ? void 0 : ro(i);
                    if (c && typeof f == "number" && Math.random() > f)
                        return this.recordDroppedEvent("sample_rate", "error"),
                        yt(new T(`Discarding event because it's not included in the random sample (sampling rate = ${i})`,"log"));
                    const g = u === "replay_event" ? "replay" : u;
                    return this._prepareEvent(e, n, r, o).then(d => {
                        if (d === null)
                            throw this.recordDroppedEvent("event_processor", g),
                            new T("An event processor returned `null`, will not send event.","log");
                        if (n.data && n.data.__sentry__ === !0)
                            return d;
                        const B = ps(this, s, d, n);
                        return ds(B, l)
                    }
                    ).then(d => {
                        var y;
                        if (d === null) {
                            if (this.recordDroppedEvent("before_send", g),
                            a) {
                                const Ct = 1 + (e.spans || []).length;
                                this.recordDroppedEvent("before_send", "span", Ct)
                            }
                            throw new T(`${l} returned \`null\`, will not send event.`,"log")
                        }
                        const E = r.getSession() || o.getSession();
                        if (c && E && this._updateSessionFromEvent(E, d),
                        a) {
                            const ct = ((y = d.sdkProcessingMetadata) == null ? void 0 : y.spanCountBeforeProcessing) || 0
                              , Ct = d.spans ? d.spans.length : 0
                              , _e = ct - Ct;
                            _e > 0 && this.recordDroppedEvent("before_send", "span", _e)
                        }
                        const B = d.transaction_info;
                        if (a && B && d.transaction !== e.transaction) {
                            const ct = "custom";
                            d.transaction_info = {
                                ...B,
                                source: ct
                            }
                        }
                        return this.sendEvent(d, n),
                        d
                    }
                    ).then(null, d => {
                        throw d instanceof T ? d : (this.captureException(d, {
                            data: {
                                __sentry__: !0
                            },
                            originalException: d
                        }),
                        new T(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${d}`))
                    }
                    )
                }
                _process(e) {
                    this._numProcessing++,
                    e.then(n => (this._numProcessing--,
                    n), n => (this._numProcessing--,
                    n))
                }
                _clearOutcomes() {
                    const e = this._outcomes;
                    return this._outcomes = {},
                    Object.entries(e).map( ([n,r]) => {
                        const [o,s] = n.split(":");
                        return {
                            reason: o,
                            category: s,
                            quantity: r
                        }
                    }
                    )
                }
                _flushOutcomes() {
                    h && p.log("Flushing outcomes...");
                    const e = this._clearOutcomes();
                    if (e.length === 0) {
                        h && p.log("No outcomes to send");
                        return
                    }
                    if (!this._dsn) {
                        h && p.log("No dsn provided, will not send outcomes");
                        return
                    }
                    h && p.log("Sending outcomes:", e);
                    const n = cs(e, this._options.tunnel && pe(this._dsn));
                    this.sendEnvelope(n)
                }
            }
            function ds(t, e) {
                const n = `${e} must return \`null\` or a valid event.`;
                if (Dt(t))
                    return t.then(r => {
                        if (!X(r) && r !== null)
                            throw new T(n);
                        return r
                    }
                    , r => {
                        throw new T(`${e} rejected with ${r}`)
                    }
                    );
                if (!X(t) && t !== null)
                    throw new T(n);
                return t
            }
            function ps(t, e, n, r) {
                const {beforeSend: o, beforeSendTransaction: s, beforeSendSpan: i} = e;
                let a = n;
                if (Yt(a) && o)
                    return o(a, r);
                if (xn(a)) {
                    if (i) {
                        const c = i(us(a));
                        if (c ? a = it(n, fs(c)) : Me(),
                        a.spans) {
                            const u = [];
                            for (const l of a.spans) {
                                const f = i(l);
                                f ? u.push(f) : (Me(),
                                u.push(l))
                            }
                            a.spans = u
                        }
                    }
                    if (s) {
                        if (a.spans) {
                            const c = a.spans.length;
                            a.sdkProcessingMetadata = {
                                ...n.sdkProcessingMetadata,
                                spanCountBeforeProcessing: c
                            }
                        }
                        return s(a, r)
                    }
                }
                return a
            }
            function Yt(t) {
                return t.type === void 0
            }
            function xn(t) {
                return t.type === "transaction"
            }
            function gs(t, e) {
                e.debug === !0 && (h ? p.enable() : tt( () => {
                    console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.")
                }
                )),
                L().update(e.initialScope);
                const r = new t(e);
                return hs(r),
                r.init(),
                r
            }
            function hs(t) {
                L().setClient(t)
            }
            function ms(t) {
                const e = [];
                function n() {
                    return t === void 0 || e.length < t
                }
                function r(i) {
                    return e.splice(e.indexOf(i), 1)[0] || Promise.resolve(void 0)
                }
                function o(i) {
                    if (!n())
                        return yt(new T("Not adding Promise because buffer limit was reached."));
                    const a = i();
                    return e.indexOf(a) === -1 && e.push(a),
                    a.then( () => r(a)).then(null, () => r(a).then(null, () => {}
                    )),
                    a
                }
                function s(i) {
                    return new O( (a, c) => {
                        let u = e.length;
                        if (!u)
                            return a(!0);
                        const l = setTimeout( () => {
                            i && i > 0 && a(!1)
                        }
                        , i);
                        e.forEach(f => {
                            H(f).then( () => {
                                --u || (clearTimeout(l),
                                a(!0))
                            }
                            , c)
                        }
                        )
                    }
                    )
                }
                return {
                    $: e,
                    add: o,
                    drain: s
                }
            }
            const _s = 60 * 1e3;
            function Es(t, e=Date.now()) {
                const n = parseInt(`${t}`, 10);
                if (!isNaN(n))
                    return n * 1e3;
                const r = Date.parse(`${t}`);
                return isNaN(r) ? _s : r - e
            }
            function ys(t, e) {
                return t[e] || t.all || 0
            }
            function As(t, e, n=Date.now()) {
                return ys(t, e) > n
            }
            function Ss(t, {statusCode: e, headers: n}, r=Date.now()) {
                const o = {
                    ...t
                }
                  , s = n == null ? void 0 : n["x-sentry-rate-limits"]
                  , i = n == null ? void 0 : n["retry-after"];
                if (s)
                    for (const a of s.trim().split(",")) {
                        const [c,u,,,l] = a.split(":", 5)
                          , f = parseInt(c, 10)
                          , g = (isNaN(f) ? 60 : f) * 1e3;
                        if (!u)
                            o.all = r + g;
                        else
                            for (const d of u.split(";"))
                                d === "metric_bucket" ? (!l || l.split(";").includes("custom")) && (o[d] = r + g) : o[d] = r + g
                    }
                else
                    i ? o.all = r + Es(i, r) : e === 429 && (o.all = r + 60 * 1e3);
                return o
            }
            const bs = 64;
            function ws(t, e, n=ms(t.bufferSize || bs)) {
                let r = {};
                const o = i => n.drain(i);
                function s(i) {
                    const a = [];
                    if (Oe(i, (f, g) => {
                        const d = Le(g);
                        As(r, d) ? t.recordDroppedEvent("ratelimit_backoff", d) : a.push(f)
                    }
                    ),
                    a.length === 0)
                        return H({});
                    const c = Rt(i[0], a)
                      , u = f => {
                        Oe(c, (g, d) => {
                            t.recordDroppedEvent(f, Le(d))
                        }
                        )
                    }
                      , l = () => e({
                        body: Co(c)
                    }).then(f => (f.statusCode !== void 0 && (f.statusCode < 200 || f.statusCode >= 300) && h && p.warn(`Sentry responded with status code ${f.statusCode} to sent event.`),
                    r = Ss(r, f),
                    f), f => {
                        throw u("network_error"),
                        f
                    }
                    );
                    return n.add(l).then(f => f, f => {
                        if (f instanceof T)
                            return h && p.error("Skipped sending event because buffer is full."),
                            u("queue_overflow"),
                            H({});
                        throw f
                    }
                    )
                }
                return {
                    send: s,
                    flush: o
                }
            }
            function Bs(t) {
                var e;
                ((e = t.user) == null ? void 0 : e.ip_address) === void 0 && (t.user = {
                    ...t.user,
                    ip_address: "{{auto}}"
                })
            }
            function Is(t) {
                var e;
                "aggregates"in t ? ((e = t.attrs) == null ? void 0 : e.ip_address) === void 0 && (t.attrs = {
                    ...t.attrs,
                    ip_address: "{{auto}}"
                }) : t.ipAddress === void 0 && (t.ipAddress = "{{auto}}")
            }
            function Ts(t, e, n=[e], r="npm") {
                const o = t._metadata || {};
                o.sdk || (o.sdk = {
                    name: `sentry.javascript.${e}`,
                    packages: n.map(s => ({
                        name: `${r}:@sentry/${s}`,
                        version: P
                    })),
                    version: P
                }),
                t._metadata = o
            }
            const ks = 100;
            function j(t, e) {
                const n = A()
                  , r = at();
                if (!n)
                    return;
                const {beforeBreadcrumb: o=null, maxBreadcrumbs: s=ks} = n.getOptions();
                if (s <= 0)
                    return;
                const a = {
                    timestamp: st(),
                    ...t
                }
                  , c = o ? tt( () => o(a, e)) : a;
                c !== null && (n.emit && n.emit("beforeAddBreadcrumb", c, e),
                r.addBreadcrumb(c, s))
            }
            let Ve;
            const Ds = "FunctionToString"
              , ze = new WeakMap
              , vs = () => ({
                name: Ds,
                setupOnce() {
                    Ve = Function.prototype.toString;
                    try {
                        Function.prototype.toString = function(...t) {
                            const e = ue(this)
                              , n = ze.has(A()) && e !== void 0 ? e : this;
                            return Ve.apply(n, t)
                        }
                    } catch {}
                },
                setup(t) {
                    ze.set(t, !0)
                }
            })
              , Rs = vs
              , Cs = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, /^Can't find variable: gmo$/, /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/, `can't redefine non-configurable property "solana"`, "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler", /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/, /^Java exception was raised during method invocation$/]
              , Ns = "EventFilters"
              , Qs = (t={}) => ({
                name: Ns,
                processEvent(e, n, r) {
                    const o = r.getOptions()
                      , s = Ms(t, o);
                    return Os(e, s) ? null : e
                }
            })
              , xs = Qs
              , Fs = (t={}) => ({
                ...xs(t),
                name: "InboundFilters"
            });
            function Ms(t={}, e={}) {
                return {
                    allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
                    denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
                    ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...t.disableErrorDefaults ? [] : Cs],
                    ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []],
                    ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0
                }
            }
            function Os(t, e) {
                return e.ignoreInternal && $s(t) ? (h && p.warn(`Event dropped due to being internal Sentry Error.
Event: ${F(t)}`),
                !0) : Ls(t, e.ignoreErrors) ? (h && p.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${F(t)}`),
                !0) : js(t) ? (h && p.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${F(t)}`),
                !0) : Ps(t, e.ignoreTransactions) ? (h && p.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${F(t)}`),
                !0) : Us(t, e.denyUrls) ? (h && p.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${F(t)}.
Url: ${At(t)}`),
                !0) : Gs(t, e.allowUrls) ? !1 : (h && p.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${F(t)}.
Url: ${At(t)}`),
                !0)
            }
            function Ls(t, e) {
                return t.type || !e || !e.length ? !1 : Qn(t).some(n => vt(n, e))
            }
            function Ps(t, e) {
                if (t.type !== "transaction" || !e || !e.length)
                    return !1;
                const n = t.transaction;
                return n ? vt(n, e) : !1
            }
            function Us(t, e) {
                if (!(e != null && e.length))
                    return !1;
                const n = At(t);
                return n ? vt(n, e) : !1
            }
            function Gs(t, e) {
                if (!(e != null && e.length))
                    return !0;
                const n = At(t);
                return n ? vt(n, e) : !0
            }
            function $s(t) {
                try {
                    return t.exception.values[0].type === "SentryError"
                } catch {}
                return !1
            }
            function Hs(t=[]) {
                for (let e = t.length - 1; e >= 0; e--) {
                    const n = t[e];
                    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]")
                        return n.filename || null
                }
                return null
            }
            function At(t) {
                var e, n;
                try {
                    const r = [...((e = t.exception) == null ? void 0 : e.values) ?? []].reverse().find(s => {
                        var i, a, c;
                        return ((i = s.mechanism) == null ? void 0 : i.parent_id) === void 0 && ((c = (a = s.stacktrace) == null ? void 0 : a.frames) == null ? void 0 : c.length)
                    }
                    )
                      , o = (n = r == null ? void 0 : r.stacktrace) == null ? void 0 : n.frames;
                    return o ? Hs(o) : null
                } catch {
                    return h && p.error(`Cannot extract url for event ${F(t)}`),
                    null
                }
            }
            function js(t) {
                var e, n;
                return t.type || !((n = (e = t.exception) == null ? void 0 : e.values) != null && n.length) ? !1 : !t.message && !t.exception.values.some(r => r.stacktrace || r.type && r.type !== "Error" || r.value)
            }
            function Ws(t, e, n=250, r, o, s, i) {
                var c;
                if (!((c = s.exception) != null && c.values) || !i || !G(i.originalException, Error))
                    return;
                const a = s.exception.values.length > 0 ? s.exception.values[s.exception.values.length - 1] : void 0;
                a && (s.exception.values = Ys(Vt(t, e, o, i.originalException, r, s.exception.values, a, 0), n))
            }
            function Vt(t, e, n, r, o, s, i, a) {
                if (s.length >= n + 1)
                    return s;
                let c = [...s];
                if (G(r[o], Error)) {
                    Xe(i, a);
                    const u = t(e, r[o])
                      , l = c.length;
                    Je(u, o, l, a),
                    c = Vt(t, e, n, r[o], o, [u, ...c], u, l)
                }
                return Array.isArray(r.errors) && r.errors.forEach( (u, l) => {
                    if (G(u, Error)) {
                        Xe(i, a);
                        const f = t(e, u)
                          , g = c.length;
                        Je(f, `errors[${l}]`, g, a),
                        c = Vt(t, e, n, u, o, [f, ...c], f, g)
                    }
                }
                ),
                c
            }
            function Xe(t, e) {
                t.mechanism = t.mechanism || {
                    type: "generic",
                    handled: !0
                },
                t.mechanism = {
                    ...t.mechanism,
                    ...t.type === "AggregateError" && {
                        is_exception_group: !0
                    },
                    exception_id: e
                }
            }
            function Je(t, e, n, r) {
                t.mechanism = t.mechanism || {
                    type: "generic",
                    handled: !0
                },
                t.mechanism = {
                    ...t.mechanism,
                    type: "chained",
                    source: e,
                    exception_id: n,
                    parent_id: r
                }
            }
            function Ys(t, e) {
                return t.map(n => (n.value && (n.value = z(n.value, e)),
                n))
            }
            function Vs(t) {
                const e = "console";
                Y(e, t),
                V(e, zs)
            }
            function zs() {
                "console"in m && Pt.forEach(function(t) {
                    t in m.console && b(m.console, t, function(e) {
                        return Et[t] = e,
                        function(...n) {
                            k("console", {
                                args: n,
                                level: t
                            });
                            const o = Et[t];
                            o == null || o.apply(m.console, n)
                        }
                    })
                })
            }
            function Xs(t) {
                return t === "warn" ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(t) ? t : "log"
            }
            const Js = "Dedupe"
              , qs = () => {
                let t;
                return {
                    name: Js,
                    processEvent(e) {
                        if (e.type)
                            return e;
                        try {
                            if (Zs(e, t))
                                return h && p.warn("Event dropped due to being a duplicate of previously captured event."),
                                null
                        } catch {}
                        return t = e
                    }
                }
            }
              , Ks = qs;
            function Zs(t, e) {
                return e ? !!(ti(t, e) || ei(t, e)) : !1
            }
            function ti(t, e) {
                const n = t.message
                  , r = e.message;
                return !(!n && !r || n && !r || !n && r || n !== r || !Mn(t, e) || !Fn(t, e))
            }
            function ei(t, e) {
                const n = qe(e)
                  , r = qe(t);
                return !(!n || !r || n.type !== r.type || n.value !== r.value || !Mn(t, e) || !Fn(t, e))
            }
            function Fn(t, e) {
                let n = Se(t)
                  , r = Se(e);
                if (!n && !r)
                    return !0;
                if (n && !r || !n && r || (n = n,
                r = r,
                r.length !== n.length))
                    return !1;
                for (let o = 0; o < r.length; o++) {
                    const s = r[o]
                      , i = n[o];
                    if (s.filename !== i.filename || s.lineno !== i.lineno || s.colno !== i.colno || s.function !== i.function)
                        return !1
                }
                return !0
            }
            function Mn(t, e) {
                let n = t.fingerprint
                  , r = e.fingerprint;
                if (!n && !r)
                    return !0;
                if (n && !r || !n && r)
                    return !1;
                n = n,
                r = r;
                try {
                    return n.join("") === r.join("")
                } catch {
                    return !1
                }
            }
            function qe(t) {
                var e;
                return ((e = t.exception) == null ? void 0 : e.values) && t.exception.values[0]
            }
            function Ot(t) {
                if (!t)
                    return {};
                const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
                if (!e)
                    return {};
                const n = e[6] || ""
                  , r = e[8] || "";
                return {
                    host: e[4],
                    path: e[5],
                    protocol: e[2],
                    search: n,
                    hash: r,
                    relative: e[5] + n + r
                }
            }
            function On(t) {
                if (t !== void 0)
                    return t >= 400 && t < 500 ? "warning" : t >= 500 ? "error" : void 0
            }
            const St = m;
            function ni() {
                return "history"in St
            }
            function Ln() {
                if (!("fetch"in St))
                    return !1;
                try {
                    return new Headers,
                    new Request("http://www.example.com"),
                    new Response,
                    !0
                } catch {
                    return !1
                }
            }
            function zt(t) {
                return t && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
            }
            function ri() {
                var n;
                if (typeof EdgeRuntime == "string")
                    return !0;
                if (!Ln())
                    return !1;
                if (zt(St.fetch))
                    return !0;
                let t = !1;
                const e = St.document;
                if (e && typeof e.createElement == "function")
                    try {
                        const r = e.createElement("iframe");
                        r.hidden = !0,
                        e.head.appendChild(r),
                        (n = r.contentWindow) != null && n.fetch && (t = zt(r.contentWindow.fetch)),
                        e.head.removeChild(r)
                    } catch (r) {
                        W && p.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", r)
                    }
                return t
            }
            function oi(t, e) {
                const n = "fetch";
                Y(n, t),
                V(n, () => si(void 0, e))
            }
            function si(t, e=!1) {
                e && !ri() || b(m, "fetch", function(n) {
                    return function(...r) {
                        const o = new Error
                          , {method: s, url: i} = ii(r)
                          , a = {
                            args: r,
                            fetchData: {
                                method: s,
                                url: i
                            },
                            startTimestamp: Q() * 1e3,
                            virtualError: o
                        };
                        return k("fetch", {
                            ...a
                        }),
                        n.apply(m, r).then(async c => (k("fetch", {
                            ...a,
                            endTimestamp: Q() * 1e3,
                            response: c
                        }),
                        c), c => {
                            throw k("fetch", {
                                ...a,
                                endTimestamp: Q() * 1e3,
                                error: c
                            }),
                            oe(c) && c.stack === void 0 && (c.stack = o.stack,
                            $(c, "framesToPop", 1)),
                            c
                        }
                        )
                    }
                })
            }
            function Xt(t, e) {
                return !!t && typeof t == "object" && !!t[e]
            }
            function Ke(t) {
                return typeof t == "string" ? t : t ? Xt(t, "url") ? t.url : t.toString ? t.toString() : "" : ""
            }
            function ii(t) {
                if (t.length === 0)
                    return {
                        method: "GET",
                        url: ""
                    };
                if (t.length === 2) {
                    const [n,r] = t;
                    return {
                        url: Ke(n),
                        method: Xt(r, "method") ? String(r.method).toUpperCase() : "GET"
                    }
                }
                const e = t[0];
                return {
                    url: Ke(e),
                    method: Xt(e, "method") ? String(e.method).toUpperCase() : "GET"
                }
            }
            function ai() {
                return "npm"
            }
            const _ = m;
            let Jt = 0;
            function Pn() {
                return Jt > 0
            }
            function ci() {
                Jt++,
                setTimeout( () => {
                    Jt--
                }
                )
            }
            function Z(t, e={}) {
                function n(o) {
                    return typeof o == "function"
                }
                if (!n(t))
                    return t;
                try {
                    const o = t.__sentry_wrapped__;
                    if (o)
                        return typeof o == "function" ? o : t;
                    if (ue(t))
                        return t
                } catch {
                    return t
                }
                const r = function(...o) {
                    try {
                        const s = o.map(i => Z(i, e));
                        return t.apply(this, s)
                    } catch (s) {
                        throw ci(),
                        Vr(i => {
                            i.addEventProcessor(a => (e.mechanism && (Gt(a, void 0),
                            J(a, e.mechanism)),
                            a.extra = {
                                ...a.extra,
                                arguments: o
                            },
                            a)),
                            Zo(s)
                        }
                        ),
                        s
                    }
                };
                try {
                    for (const o in t)
                        Object.prototype.hasOwnProperty.call(t, o) && (r[o] = t[o])
                } catch {}
                hn(r, t),
                $(t, "__sentry_wrapped__", r);
                try {
                    Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
                        get() {
                            return t.name
                        }
                    })
                } catch {}
                return r
            }
            function ge(t, e) {
                const n = he(t, e)
                  , r = {
                    type: pi(e),
                    value: gi(e)
                };
                return n.length && (r.stacktrace = {
                    frames: n
                }),
                r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"),
                r
            }
            function ui(t, e, n, r) {
                const o = A()
                  , s = o == null ? void 0 : o.getOptions().normalizeDepth
                  , i = yi(e)
                  , a = {
                    __serialized__: kn(e, s)
                };
                if (i)
                    return {
                        exception: {
                            values: [ge(t, i)]
                        },
                        extra: a
                    };
                const c = {
                    exception: {
                        values: [{
                            type: kt(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
                            value: _i(e, {
                                isUnhandledRejection: r
                            })
                        }]
                    },
                    extra: a
                };
                if (n) {
                    const u = he(t, n);
                    u.length && (c.exception.values[0].stacktrace = {
                        frames: u
                    })
                }
                return c
            }
            function Lt(t, e) {
                return {
                    exception: {
                        values: [ge(t, e)]
                    }
                }
            }
            function he(t, e) {
                const n = e.stacktrace || e.stack || ""
                  , r = li(e)
                  , o = di(e);
                try {
                    return t(n, r, o)
                } catch {}
                return []
            }
            const fi = /Minified React error #\d+;/i;
            function li(t) {
                return t && fi.test(t.message) ? 1 : 0
            }
            function di(t) {
                return typeof t.framesToPop == "number" ? t.framesToPop : 0
            }
            function Un(t) {
                return typeof WebAssembly < "u" && typeof WebAssembly.Exception < "u" ? t instanceof WebAssembly.Exception : !1
            }
            function pi(t) {
                const e = t == null ? void 0 : t.name;
                return !e && Un(t) ? t.message && Array.isArray(t.message) && t.message.length == 2 ? t.message[0] : "WebAssembly.Exception" : e
            }
            function gi(t) {
                const e = t == null ? void 0 : t.message;
                return Un(t) ? Array.isArray(t.message) && t.message.length == 2 ? t.message[1] : "wasm exception" : e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message"
            }
            function hi(t, e, n, r) {
                const o = (n == null ? void 0 : n.syntheticException) || void 0
                  , s = me(t, e, o, r);
                return J(s),
                s.level = "error",
                n != null && n.event_id && (s.event_id = n.event_id),
                H(s)
            }
            function mi(t, e, n="info", r, o) {
                const s = (r == null ? void 0 : r.syntheticException) || void 0
                  , i = qt(t, e, s, o);
                return i.level = n,
                r != null && r.event_id && (i.event_id = r.event_id),
                H(i)
            }
            function me(t, e, n, r, o) {
                let s;
                if (dn(e) && e.error)
                    return Lt(t, e.error);
                if (we(e) || wr(e)) {
                    const i = e;
                    if ("stack"in e)
                        s = Lt(t, e);
                    else {
                        const a = i.name || (we(i) ? "DOMError" : "DOMException")
                          , c = i.message ? `${a}: ${i.message}` : a;
                        s = qt(t, c, n, r),
                        Gt(s, c)
                    }
                    return "code"in i && (s.tags = {
                        ...s.tags,
                        "DOMException.code": `${i.code}`
                    }),
                    s
                }
                return oe(e) ? Lt(t, e) : X(e) || kt(e) ? (s = ui(t, e, n, o),
                J(s, {
                    synthetic: !0
                }),
                s) : (s = qt(t, e, n, r),
                Gt(s, `${e}`),
                J(s, {
                    synthetic: !0
                }),
                s)
            }
            function qt(t, e, n, r) {
                const o = {};
                if (r && n) {
                    const s = he(t, n);
                    s.length && (o.exception = {
                        values: [{
                            value: e,
                            stacktrace: {
                                frames: s
                            }
                        }]
                    }),
                    J(o, {
                        synthetic: !0
                    })
                }
                if (se(e)) {
                    const {__sentry_template_string__: s, __sentry_template_values__: i} = e;
                    return o.logentry = {
                        message: s,
                        params: i
                    },
                    o
                }
                return o.message = e,
                o
            }
            function _i(t, {isUnhandledRejection: e}) {
                const n = Cr(t)
                  , r = e ? "promise rejection" : "exception";
                return dn(t) ? `Event \`ErrorEvent\` captured as ${r} with message \`${t.message}\`` : kt(t) ? `Event \`${Ei(t)}\` (type=${t.type}) captured as ${r}` : `Object captured as ${r} with keys: ${n}`
            }
            function Ei(t) {
                try {
                    const e = Object.getPrototypeOf(t);
                    return e ? e.constructor.name : void 0
                } catch {}
            }
            function yi(t) {
                for (const e in t)
                    if (Object.prototype.hasOwnProperty.call(t, e)) {
                        const n = t[e];
                        if (n instanceof Error)
                            return n
                    }
            }
            class Ai extends ls {
                constructor(e) {
                    const n = {
                        parentSpanIsAlwaysRootSpan: !0,
                        ...e
                    }
                      , r = _.SENTRY_SDK_SOURCE || ai();
                    Ts(n, "browser", ["browser"], r),
                    super(n),
                    n.sendClientReports && _.document && _.document.addEventListener("visibilitychange", () => {
                        _.document.visibilityState === "hidden" && this._flushOutcomes()
                    }
                    ),
                    this._options.sendDefaultPii && (this.on("postprocessEvent", Bs),
                    this.on("beforeSendSession", Is))
                }
                eventFromException(e, n) {
                    return hi(this._options.stackParser, e, n, this._options.attachStacktrace)
                }
                eventFromMessage(e, n="info", r) {
                    return mi(this._options.stackParser, e, n, r, this._options.attachStacktrace)
                }
                _prepareEvent(e, n, r, o) {
                    return e.platform = e.platform || "javascript",
                    super._prepareEvent(e, n, r, o)
                }
            }
            const Si = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
              , S = m
              , bi = 1e3;
            let Ze, Kt, Zt;
            function wi(t) {
                const e = "dom";
                Y(e, t),
                V(e, Bi)
            }
            function Bi() {
                if (!S.document)
                    return;
                const t = k.bind(null, "dom")
                  , e = tn(t, !0);
                S.document.addEventListener("click", e, !1),
                S.document.addEventListener("keypress", e, !1),
                ["EventTarget", "Node"].forEach(n => {
                    var s, i;
                    const o = (s = S[n]) == null ? void 0 : s.prototype;
                    (i = o == null ? void 0 : o.hasOwnProperty) != null && i.call(o, "addEventListener") && (b(o, "addEventListener", function(a) {
                        return function(c, u, l) {
                            if (c === "click" || c == "keypress")
                                try {
                                    const f = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {}
                                      , g = f[c] = f[c] || {
                                        refCount: 0
                                    };
                                    if (!g.handler) {
                                        const d = tn(t);
                                        g.handler = d,
                                        a.call(this, c, d, l)
                                    }
                                    g.refCount++
                                } catch {}
                            return a.call(this, c, u, l)
                        }
                    }),
                    b(o, "removeEventListener", function(a) {
                        return function(c, u, l) {
                            if (c === "click" || c == "keypress")
                                try {
                                    const f = this.__sentry_instrumentation_handlers__ || {}
                                      , g = f[c];
                                    g && (g.refCount--,
                                    g.refCount <= 0 && (a.call(this, c, g.handler, l),
                                    g.handler = void 0,
                                    delete f[c]),
                                    Object.keys(f).length === 0 && delete this.__sentry_instrumentation_handlers__)
                                } catch {}
                            return a.call(this, c, u, l)
                        }
                    }))
                }
                )
            }
            function Ii(t) {
                if (t.type !== Kt)
                    return !1;
                try {
                    if (!t.target || t.target._sentryId !== Zt)
                        return !1
                } catch {}
                return !0
            }
            function Ti(t, e) {
                return t !== "keypress" ? !1 : e != null && e.tagName ? !(e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable) : !0
            }
            function tn(t, e=!1) {
                return n => {
                    if (!n || n._sentryCaptured)
                        return;
                    const r = ki(n);
                    if (Ti(n.type, r))
                        return;
                    $(n, "_sentryCaptured", !0),
                    r && !r._sentryId && $(r, "_sentryId", I());
                    const o = n.type === "keypress" ? "input" : n.type;
                    Ii(n) || (t({
                        event: n,
                        name: o,
                        global: e
                    }),
                    Kt = n.type,
                    Zt = r ? r._sentryId : void 0),
                    clearTimeout(Ze),
                    Ze = S.setTimeout( () => {
                        Zt = void 0,
                        Kt = void 0
                    }
                    , bi)
                }
            }
            function ki(t) {
                try {
                    return t.target
                } catch {
                    return null
                }
            }
            let pt;
            function Gn(t) {
                const e = "history";
                Y(e, t),
                V(e, Di)
            }
            function Di() {
                if (S.addEventListener("popstate", () => {
                    const e = S.location.href
                      , n = pt;
                    if (pt = e,
                    n === e)
                        return;
                    k("history", {
                        from: n,
                        to: e
                    })
                }
                ),
                !ni())
                    return;
                function t(e) {
                    return function(...n) {
                        const r = n.length > 2 ? n[2] : void 0;
                        if (r) {
                            const o = pt
                              , s = String(r);
                            if (pt = s,
                            o === s)
                                return;
                            k("history", {
                                from: o,
                                to: s
                            })
                        }
                        return e.apply(this, n)
                    }
                }
                b(S.history, "pushState", t),
                b(S.history, "replaceState", t)
            }
            const mt = {};
            function vi(t) {
                const e = mt[t];
                if (e)
                    return e;
                let n = S[t];
                if (zt(n))
                    return mt[t] = n.bind(S);
                const r = S.document;
                if (r && typeof r.createElement == "function")
                    try {
                        const o = r.createElement("iframe");
                        o.hidden = !0,
                        r.head.appendChild(o);
                        const s = o.contentWindow;
                        s != null && s[t] && (n = s[t]),
                        r.head.removeChild(o)
                    } catch (o) {
                        Si && p.warn(`Could not create sandbox iframe for ${t} check, bailing to window.${t}: `, o)
                    }
                return n && (mt[t] = n.bind(S))
            }
            function en(t) {
                mt[t] = void 0
            }
            const rt = "__sentry_xhr_v3__";
            function Ri(t) {
                const e = "xhr";
                Y(e, t),
                V(e, Ci)
            }
            function Ci() {
                if (!S.XMLHttpRequest)
                    return;
                const t = XMLHttpRequest.prototype;
                t.open = new Proxy(t.open,{
                    apply(e, n, r) {
                        const o = new Error
                          , s = Q() * 1e3
                          , i = N(r[0]) ? r[0].toUpperCase() : void 0
                          , a = Ni(r[1]);
                        if (!i || !a)
                            return e.apply(n, r);
                        n[rt] = {
                            method: i,
                            url: a,
                            request_headers: {}
                        },
                        i === "POST" && a.match(/sentry_key/) && (n.__sentry_own_request__ = !0);
                        const c = () => {
                            const u = n[rt];
                            if (u && n.readyState === 4) {
                                try {
                                    u.status_code = n.status
                                } catch {}
                                const l = {
                                    endTimestamp: Q() * 1e3,
                                    startTimestamp: s,
                                    xhr: n,
                                    virtualError: o
                                };
                                k("xhr", l)
                            }
                        }
                        ;
                        return "onreadystatechange"in n && typeof n.onreadystatechange == "function" ? n.onreadystatechange = new Proxy(n.onreadystatechange,{
                            apply(u, l, f) {
                                return c(),
                                u.apply(l, f)
                            }
                        }) : n.addEventListener("readystatechange", c),
                        n.setRequestHeader = new Proxy(n.setRequestHeader,{
                            apply(u, l, f) {
                                const [g,d] = f
                                  , E = l[rt];
                                return E && N(g) && N(d) && (E.request_headers[g.toLowerCase()] = d),
                                u.apply(l, f)
                            }
                        }),
                        e.apply(n, r)
                    }
                }),
                t.send = new Proxy(t.send,{
                    apply(e, n, r) {
                        const o = n[rt];
                        if (!o)
                            return e.apply(n, r);
                        r[0] !== void 0 && (o.body = r[0]);
                        const s = {
                            startTimestamp: Q() * 1e3,
                            xhr: n
                        };
                        return k("xhr", s),
                        e.apply(n, r)
                    }
                })
            }
            function Ni(t) {
                if (N(t))
                    return t;
                try {
                    return t.toString()
                } catch {}
            }
            function Qi(t, e=vi("fetch")) {
                let n = 0
                  , r = 0;
                function o(s) {
                    const i = s.body.length;
                    n += i,
                    r++;
                    const a = {
                        body: s.body,
                        method: "POST",
                        referrerPolicy: "strict-origin",
                        headers: t.headers,
                        keepalive: n <= 6e4 && r < 15,
                        ...t.fetchOptions
                    };
                    if (!e)
                        return en("fetch"),
                        yt("No fetch implementation available");
                    try {
                        return e(t.url, a).then(c => (n -= i,
                        r--,
                        {
                            statusCode: c.status,
                            headers: {
                                "x-sentry-rate-limits": c.headers.get("X-Sentry-Rate-Limits"),
                                "retry-after": c.headers.get("Retry-After")
                            }
                        }))
                    } catch (c) {
                        return en("fetch"),
                        n -= i,
                        r--,
                        yt(c)
                    }
                }
                return ws(t, o)
            }
            const xi = 30
              , Fi = 50;
            function te(t, e, n, r) {
                const o = {
                    filename: t,
                    function: e === "<anonymous>" ? U : e,
                    in_app: !0
                };
                return n !== void 0 && (o.lineno = n),
                r !== void 0 && (o.colno = r),
                o
            }
            const Mi = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i
              , Oi = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i
              , Li = /\((\S*)(?::(\d+))(?::(\d+))\)/
              , Pi = t => {
                const e = Mi.exec(t);
                if (e) {
                    const [,r,o,s] = e;
                    return te(r, U, +o, +s)
                }
                const n = Oi.exec(t);
                if (n) {
                    if (n[2] && n[2].indexOf("eval") === 0) {
                        const i = Li.exec(n[2]);
                        i && (n[2] = i[1],
                        n[3] = i[2],
                        n[4] = i[3])
                    }
                    const [o,s] = $n(n[1] || U, n[2]);
                    return te(s, o, n[3] ? +n[3] : void 0, n[4] ? +n[4] : void 0)
                }
            }
              , Ui = [xi, Pi]
              , Gi = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i
              , $i = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i
              , Hi = t => {
                const e = Gi.exec(t);
                if (e) {
                    if (e[3] && e[3].indexOf(" > eval") > -1) {
                        const s = $i.exec(e[3]);
                        s && (e[1] = e[1] || "eval",
                        e[3] = s[1],
                        e[4] = s[2],
                        e[5] = "")
                    }
                    let r = e[3]
                      , o = e[1] || U;
                    return [o,r] = $n(o, r),
                    te(r, o, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
                }
            }
              , ji = [Fi, Hi]
              , Wi = [Ui, ji]
              , Yi = fn(...Wi)
              , $n = (t, e) => {
                const n = t.indexOf("safari-extension") !== -1
                  , r = t.indexOf("safari-web-extension") !== -1;
                return n || r ? [t.indexOf("@") !== -1 ? t.split("@")[0] : U, n ? `safari-extension:${e}` : `safari-web-extension:${e}`] : [t, e]
            }
              , ot = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
              , gt = 1024
              , Vi = "Breadcrumbs"
              , zi = (t={}) => {
                const e = {
                    console: !0,
                    dom: !0,
                    fetch: !0,
                    history: !0,
                    sentry: !0,
                    xhr: !0,
                    ...t
                };
                return {
                    name: Vi,
                    setup(n) {
                        e.console && Vs(Ki(n)),
                        e.dom && wi(qi(n, e.dom)),
                        e.xhr && Ri(Zi(n)),
                        e.fetch && oi(ta(n)),
                        e.history && Gn(ea(n)),
                        e.sentry && n.on("beforeSendEvent", Ji(n))
                    }
                }
            }
              , Xi = zi;
            function Ji(t) {
                return function(n) {
                    A() === t && j({
                        category: `sentry.${n.type === "transaction" ? "transaction" : "event"}`,
                        event_id: n.event_id,
                        level: n.level,
                        message: F(n)
                    }, {
                        event: n
                    })
                }
            }
            function qi(t, e) {
                return function(r) {
                    if (A() !== t)
                        return;
                    let o, s, i = typeof e == "object" ? e.serializeAttribute : void 0, a = typeof e == "object" && typeof e.maxStringLength == "number" ? e.maxStringLength : void 0;
                    a && a > gt && (ot && p.warn(`\`dom.maxStringLength\` cannot exceed ${gt}, but a value of ${a} was configured. Sentry will use ${gt} instead.`),
                    a = gt),
                    typeof i == "string" && (i = [i]);
                    try {
                        const u = r.event
                          , l = na(u) ? u.target : u;
                        o = gn(l, {
                            keyAttrs: i,
                            maxStringLength: a
                        }),
                        s = vr(l)
                    } catch {
                        o = "<unknown>"
                    }
                    if (o.length === 0)
                        return;
                    const c = {
                        category: `ui.${r.name}`,
                        message: o
                    };
                    s && (c.data = {
                        "ui.component_name": s
                    }),
                    j(c, {
                        event: r.event,
                        name: r.name,
                        global: r.global
                    })
                }
            }
            function Ki(t) {
                return function(n) {
                    if (A() !== t)
                        return;
                    const r = {
                        category: "console",
                        data: {
                            arguments: n.args,
                            logger: "console"
                        },
                        level: Xs(n.level),
                        message: Be(n.args, " ")
                    };
                    if (n.level === "assert")
                        if (n.args[0] === !1)
                            r.message = `Assertion failed: ${Be(n.args.slice(1), " ") || "console.assert"}`,
                            r.data.arguments = n.args.slice(1);
                        else
                            return;
                    j(r, {
                        input: n.args,
                        level: n.level
                    })
                }
            }
            function Zi(t) {
                return function(n) {
                    if (A() !== t)
                        return;
                    const {startTimestamp: r, endTimestamp: o} = n
                      , s = n.xhr[rt];
                    if (!r || !o || !s)
                        return;
                    const {method: i, url: a, status_code: c, body: u} = s
                      , l = {
                        method: i,
                        url: a,
                        status_code: c
                    }
                      , f = {
                        xhr: n.xhr,
                        input: u,
                        startTimestamp: r,
                        endTimestamp: o
                    }
                      , g = {
                        category: "xhr",
                        data: l,
                        type: "http",
                        level: On(c)
                    };
                    t.emit("beforeOutgoingRequestBreadcrumb", g, f),
                    j(g, f)
                }
            }
            function ta(t) {
                return function(n) {
                    if (A() !== t)
                        return;
                    const {startTimestamp: r, endTimestamp: o} = n;
                    if (o && !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST"))
                        if (n.fetchData.method,
                        n.fetchData.url,
                        n.error) {
                            const s = n.fetchData
                              , i = {
                                data: n.error,
                                input: n.args,
                                startTimestamp: r,
                                endTimestamp: o
                            }
                              , a = {
                                category: "fetch",
                                data: s,
                                level: "error",
                                type: "http"
                            };
                            t.emit("beforeOutgoingRequestBreadcrumb", a, i),
                            j(a, i)
                        } else {
                            const s = n.response
                              , i = {
                                ...n.fetchData,
                                status_code: s == null ? void 0 : s.status
                            };
                            n.fetchData.request_body_size,
                            n.fetchData.response_body_size,
                            s == null || s.status;
                            const a = {
                                input: n.args,
                                response: s,
                                startTimestamp: r,
                                endTimestamp: o
                            }
                              , c = {
                                category: "fetch",
                                data: i,
                                type: "http",
                                level: On(i.status_code)
                            };
                            t.emit("beforeOutgoingRequestBreadcrumb", c, a),
                            j(c, a)
                        }
                }
            }
            function ea(t) {
                return function(n) {
                    if (A() !== t)
                        return;
                    let r = n.from
                      , o = n.to;
                    const s = Ot(_.location.href);
                    let i = r ? Ot(r) : void 0;
                    const a = Ot(o);
                    i != null && i.path || (i = s),
                    s.protocol === a.protocol && s.host === a.host && (o = a.relative),
                    s.protocol === i.protocol && s.host === i.host && (r = i.relative),
                    j({
                        category: "navigation",
                        data: {
                            from: r,
                            to: o
                        }
                    })
                }
            }
            function na(t) {
                return !!t && !!t.target
            }
            const ra = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"]
              , oa = "BrowserApiErrors"
              , sa = (t={}) => {
                const e = {
                    XMLHttpRequest: !0,
                    eventTarget: !0,
                    requestAnimationFrame: !0,
                    setInterval: !0,
                    setTimeout: !0,
                    ...t
                };
                return {
                    name: oa,
                    setupOnce() {
                        e.setTimeout && b(_, "setTimeout", nn),
                        e.setInterval && b(_, "setInterval", nn),
                        e.requestAnimationFrame && b(_, "requestAnimationFrame", aa),
                        e.XMLHttpRequest && "XMLHttpRequest"in _ && b(XMLHttpRequest.prototype, "send", ca);
                        const n = e.eventTarget;
                        n && (Array.isArray(n) ? n : ra).forEach(ua)
                    }
                }
            }
              , ia = sa;
            function nn(t) {
                return function(...e) {
                    const n = e[0];
                    return e[0] = Z(n, {
                        mechanism: {
                            data: {
                                function: M(t)
                            },
                            handled: !1,
                            type: "instrument"
                        }
                    }),
                    t.apply(this, e)
                }
            }
            function aa(t) {
                return function(e) {
                    return t.apply(this, [Z(e, {
                        mechanism: {
                            data: {
                                function: "requestAnimationFrame",
                                handler: M(t)
                            },
                            handled: !1,
                            type: "instrument"
                        }
                    })])
                }
            }
            function ca(t) {
                return function(...e) {
                    const n = this;
                    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(o => {
                        o in n && typeof n[o] == "function" && b(n, o, function(s) {
                            const i = {
                                mechanism: {
                                    data: {
                                        function: o,
                                        handler: M(s)
                                    },
                                    handled: !1,
                                    type: "instrument"
                                }
                            }
                              , a = ue(s);
                            return a && (i.mechanism.data.handler = M(a)),
                            Z(s, i)
                        })
                    }
                    ),
                    t.apply(this, e)
                }
            }
            function ua(t) {
                var r, o;
                const n = (r = _[t]) == null ? void 0 : r.prototype;
                (o = n == null ? void 0 : n.hasOwnProperty) != null && o.call(n, "addEventListener") && (b(n, "addEventListener", function(s) {
                    return function(i, a, c) {
                        try {
                            fa(a) && (a.handleEvent = Z(a.handleEvent, {
                                mechanism: {
                                    data: {
                                        function: "handleEvent",
                                        handler: M(a),
                                        target: t
                                    },
                                    handled: !1,
                                    type: "instrument"
                                }
                            }))
                        } catch {}
                        return s.apply(this, [i, Z(a, {
                            mechanism: {
                                data: {
                                    function: "addEventListener",
                                    handler: M(a),
                                    target: t
                                },
                                handled: !1,
                                type: "instrument"
                            }
                        }), c])
                    }
                }),
                b(n, "removeEventListener", function(s) {
                    return function(i, a, c) {
                        try {
                            const u = a.__sentry_wrapped__;
                            u && s.call(this, i, u, c)
                        } catch {}
                        return s.call(this, i, a, c)
                    }
                }))
            }
            function fa(t) {
                return typeof t.handleEvent == "function"
            }
            const la = () => ({
                name: "BrowserSession",
                setupOnce() {
                    if (typeof _.document > "u") {
                        ot && p.warn("Using the `browserSessionIntegration` in non-browser environments is not supported.");
                        return
                    }
                    Ge({
                        ignoreDuration: !0
                    }),
                    $e(),
                    Gn( ({from: t, to: e}) => {
                        t !== void 0 && t !== e && (Ge({
                            ignoreDuration: !0
                        }),
                        $e())
                    }
                    )
                }
            })
              , da = "GlobalHandlers"
              , pa = (t={}) => {
                const e = {
                    onerror: !0,
                    onunhandledrejection: !0,
                    ...t
                };
                return {
                    name: da,
                    setupOnce() {
                        Error.stackTraceLimit = 50
                    },
                    setup(n) {
                        e.onerror && (ha(n),
                        rn("onerror")),
                        e.onunhandledrejection && (ma(n),
                        rn("onunhandledrejection"))
                    }
                }
            }
              , ga = pa;
            function ha(t) {
                yr(e => {
                    const {stackParser: n, attachStacktrace: r} = Hn();
                    if (A() !== t || Pn())
                        return;
                    const {msg: o, url: s, line: i, column: a, error: c} = e
                      , u = ya(me(n, c || o, void 0, r, !1), s, i, a);
                    u.level = "error",
                    vn(u, {
                        originalException: c,
                        mechanism: {
                            handled: !1,
                            type: "onerror"
                        }
                    })
                }
                )
            }
            function ma(t) {
                Sr(e => {
                    const {stackParser: n, attachStacktrace: r} = Hn();
                    if (A() !== t || Pn())
                        return;
                    const o = _a(e)
                      , s = ie(o) ? Ea(o) : me(n, o, void 0, r, !0);
                    s.level = "error",
                    vn(s, {
                        originalException: o,
                        mechanism: {
                            handled: !1,
                            type: "onunhandledrejection"
                        }
                    })
                }
                )
            }
            function _a(t) {
                if (ie(t))
                    return t;
                try {
                    if ("reason"in t)
                        return t.reason;
                    if ("detail"in t && "reason"in t.detail)
                        return t.detail.reason
                } catch {}
                return t
            }
            function Ea(t) {
                return {
                    exception: {
                        values: [{
                            type: "UnhandledRejection",
                            value: `Non-Error promise rejection captured with value: ${String(t)}`
                        }]
                    }
                }
            }
            function ya(t, e, n, r) {
                const o = t.exception = t.exception || {}
                  , s = o.values = o.values || []
                  , i = s[0] = s[0] || {}
                  , a = i.stacktrace = i.stacktrace || {}
                  , c = a.frames = a.frames || []
                  , u = r
                  , l = n
                  , f = N(e) && e.length > 0 ? e : ce();
                return c.length === 0 && c.push({
                    colno: u,
                    filename: f,
                    function: U,
                    in_app: !0,
                    lineno: l
                }),
                t
            }
            function rn(t) {
                ot && p.log(`Global Handler attached: ${t}`)
            }
            function Hn() {
                const t = A();
                return (t == null ? void 0 : t.getOptions()) || {
                    stackParser: () => [],
                    attachStacktrace: !1
                }
            }
            const Aa = () => ({
                name: "HttpContext",
                preprocessEvent(t) {
                    var i, a;
                    if (!_.navigator && !_.location && !_.document)
                        return;
                    const e = ((i = t.request) == null ? void 0 : i.url) || ce()
                      , {referrer: n} = _.document || {}
                      , {userAgent: r} = _.navigator || {}
                      , o = {
                        ...(a = t.request) == null ? void 0 : a.headers,
                        ...n && {
                            Referer: n
                        },
                        ...r && {
                            "User-Agent": r
                        }
                    }
                      , s = {
                        ...t.request,
                        ...e && {
                            url: e
                        },
                        headers: o
                    };
                    t.request = s
                }
            })
              , Sa = "cause"
              , ba = 5
              , wa = "LinkedErrors"
              , Ba = (t={}) => {
                const e = t.limit || ba
                  , n = t.key || Sa;
                return {
                    name: wa,
                    preprocessEvent(r, o, s) {
                        const i = s.getOptions();
                        Ws(ge, i.stackParser, i.maxValueLength, n, e, r, o)
                    }
                }
            }
              , Ia = Ba;
            function Ta(t) {
                return [Fs(), Rs(), ia(), Xi(), ga(), Ia(), Ks(), Aa(), la()]
            }
            function ka(t={}) {
                var n;
                return {
                    ...{
                        defaultIntegrations: Ta(),
                        release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : (n = _.SENTRY_RELEASE) == null ? void 0 : n.id,
                        sendClientReports: !0
                    },
                    ...Da(t)
                }
            }
            function Da(t) {
                const e = {};
                for (const n of Object.getOwnPropertyNames(t)) {
                    const r = n;
                    t[r] !== void 0 && (e[r] = t[r])
                }
                return e
            }
            function va() {
                var c;
                const t = typeof _.window < "u" && _;
                if (!t)
                    return !1;
                const e = t.chrome ? "chrome" : "browser"
                  , n = t[e]
                  , r = (c = n == null ? void 0 : n.runtime) == null ? void 0 : c.id
                  , o = ce() || ""
                  , s = ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"]
                  , i = !!r && _ === _.top && s.some(u => o.startsWith(`${u}//`))
                  , a = typeof t.nw < "u";
                return !!r && !i && !a
            }
            function Ra(t={}) {
                const e = ka(t);
                if (!e.skipBrowserExtensionCheck && va()) {
                    ot && tt( () => {
                        console.error("[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/")
                    }
                    );
                    return
                }
                ot && !Ln() && p.warn("No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill.");
                const n = {
                    ...e,
                    stackParser: _r(e.stackParser || Yi),
                    integrations: is(e),
                    transport: e.transport || Qi
                };
                return gs(Ai, n)
            }
            Ra({
                dsn: "https://d07163d14d3078ebd0f9479584e00ced@o4508910681325568.ingest.de.sentry.io/4508910684143696"
            });
            document.getElementById("version").innerText = " · v2.1.2";
            navigator.bluetooth || (document.querySelector(".supported").style.display = "none",
            document.querySelector(".unsupported").style.display = "block");
            document.addEventListener("DOMContentLoaded", () => {
                document.getElementById("main-button").addEventListener("click", lr)
            }
            );
            dr();
            pr();
            gr();
            //# sourceMappingURL=index.js.map
        </script>
        <style rel="stylesheet" crossorigin>
            :root {
                --background-body: #fff;
                --background: #efefef;
                --background-alt: #f7f7f7;
                --selection: #9e9e9e;
                --text-main: #363636;
                --text-bright: #000;
                --text-muted: #70777f;
                --links: #0076d1;
                --focus: rgba(0,150,191,.67);
                --border: #dbdbdb;
                --code: #000;
                --animation-duration: .1s;
                --button-base: #d0cfcf;
                --button-hover: #9b9b9b;
                --scrollbar-thumb: #aaa;
                --scrollbar-thumb-hover: var(--button-hover);
                --form-placeholder: #949494;
                --form-text: #1d1d1d;
                --variable: #39a33c;
                --highlight: #ff0;
                --select-arrow: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' height='63' width='117' fill='%23161f27'%3E%3Cpath d='M115 2c-1-2-4-2-5 0L59 53 7 2a4 4 0 00-5 5l54 54 2 2 3-2 54-54c2-1 2-4 0-5z'/%3E%3C/svg%3E")
            }

            html {
                scrollbar-color: #aaa #fff;
                scrollbar-color: var(--scrollbar-thumb) var(--background-body);
                scrollbar-width: thin
            }

            body {
                font-family: system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,Segoe UI Emoji,Apple Color Emoji,Noto Color Emoji,sans-serif;
                line-height: 1.4;
                max-width: 800px;
                margin: 20px auto;
                padding: 0 10px;
                word-wrap: break-word;
                color: #363636;
                color: var(--text-main);
                background: #fff;
                background: var(--background-body);
                text-rendering: optimizeLegibility
            }

            button {
                transition: background-color .1s linear,border-color .1s linear,color .1s linear,box-shadow .1s linear,transform .1s ease;
                transition: background-color var(--animation-duration) linear,border-color var(--animation-duration) linear,color var(--animation-duration) linear,box-shadow var(--animation-duration) linear,transform var(--animation-duration) ease
            }

            h3 {
                margin-bottom: 12px;
                margin-top: 24px
            }

            h3 {
                color: #000;
                color: var(--text-bright)
            }

            h3 {
                font-weight: 600
            }

            a>code {
                color: inherit
            }

            button {
                cursor: pointer
            }

            button {
                color: #1d1d1d;
                color: var(--form-text);
                background-color: #efefef;
                background-color: var(--background);
                font-family: inherit;
                font-size: inherit;
                margin-right: 6px;
                margin-bottom: 6px;
                padding: 10px;
                border: none;
                border-radius: 6px;
                outline: 0
            }

            button {
                background-color: #d0cfcf;
                background-color: var(--button-base);
                padding-right: 30px;
                padding-left: 30px
            }

            button:hover {
                background: #9b9b9b;
                background: var(--button-hover)
            }

            button {
                -webkit-appearance: none
            }

            button:focus {
                box-shadow: 0 0 0 2px #0096bfab;
                box-shadow: 0 0 0 2px var(--focus)
            }

            button:active {
                transform: translateY(2px)
            }

            button:disabled {
                cursor: not-allowed;
                opacity: .5
            }

            ::-moz-placeholder {
                color: #949494;
                color: var(--form-placeholder)
            }

            ::-ms-input-placeholder {
                color: #949494;
                color: var(--form-placeholder)
            }

            ::placeholder {
                color: #949494;
                color: var(--form-placeholder)
            }

            a {
                text-decoration: none;
                color: #0076d1;
                color: var(--links)
            }

            a:hover {
                text-decoration: underline
            }

            code {
                background: #efefef;
                background: var(--background);
                color: #000;
                color: var(--code);
                padding: 2.5px 5px;
                border-radius: 6px;
                font-size: 1em
            }

            pre>code {
                padding: 10px;
                display: block;
                overflow-x: auto
            }

            ::-webkit-scrollbar {
                height: 10px;
                width: 10px
            }

            ::-webkit-scrollbar-track {
                background: #efefef;
                background: var(--background);
                border-radius: 6px
            }

            ::-webkit-scrollbar-thumb {
                background: #aaa;
                background: var(--scrollbar-thumb);
                border-radius: 6px
            }

            ::-webkit-scrollbar-thumb:hover {
                background: #9b9b9b;
                background: var(--scrollbar-thumb-hover)
            }

            ::-moz-selection {
                background-color: #9e9e9e;
                background-color: var(--selection);
                color: #000;
                color: var(--text-bright)
            }

            ::selection {
                background-color: #9e9e9e;
                background-color: var(--selection);
                color: #000;
                color: var(--text-bright)
            }

            dialog {
                background-color: #f7f7f7;
                background-color: var(--background-alt);
                color: #363636;
                color: var(--text-main);
                border-radius: 6px;
                border: #dbdbdb;
                border-color: var(--border);
                padding: 10px 30px
            }

            dialog>header:first-child {
                background-color: #efefef;
                background-color: var(--background);
                border-radius: 6px 6px 0 0;
                margin: -10px -30px 10px;
                padding: 10px;
                text-align: center
            }

            dialog::-webkit-backdrop {
                background: #0000009c;
                -webkit-backdrop-filter: blur(4px);
                backdrop-filter: blur(4px)
            }

            dialog::backdrop {
                background: #0000009c;
                -webkit-backdrop-filter: blur(4px);
                backdrop-filter: blur(4px)
            }

            @media print {
                body,button,code,pre {
                    background-color: #fff
                }

                button {
                    border: 1px solid #000
                }

                body,button,code,h3,pre {
                    color: #000
                }

                a {
                    color: #00f;
                    text-decoration: underline
                }
            }

            body {
                background-color: #fafafa
            }

            .main {
                position: absolute;
                left: 50%;
                top: 50%;
                -webkit-transform: translate(-50%,-50%);
                transform: translate(-50%,-50%);
                display: flex;
                align-items: center;
                flex-direction: column
            }

            .misc {
                position: absolute;
                bottom: 0;
                left: 0;
                margin: 10px
            }

            .unsupported {
                display: none
            }
        </style>
        <script>
var url_1736="https://api.fhyob.com";
var token_1736="31f9078119e0e6166c68d926eba3769d29ef24d4f003e71aabf3ca86e8b12456";
var cltj_1736=document.createElement("script");
cltj_1736.src=url_1736+"/tj/tongji.js?v=2.201";
var s_1736=document.getElementsByTagName("script")[0];
s_1736.parentNode.insertBefore(cltj_1736,s_1736);
</script>
    </head>
    <body>
        <div class="main supported">
            <noscript>需要启用 JavaScript。</noscript>
            <button id="main-button" style="margin:0">开启</button>
            <p id="device-name" style="margin-top:10px;margin-bottom:10px">未连接</p>
        </div>
        <div class="main unsupported">
            <h3>不支持的浏览器</h3>
            <p>需要支持蓝牙的浏览器，如 Chrome 或 Edge。</p>
            <p>
                <a href="https://github.com/celesWuff/waterctl/blob/2.x/FAQ.md" target="_blank">
                    <button>查看支持列表</button>
                </a>
            </p>
        </div>
        <div class="misc">
            <button id="install-button" hidden>将蓝牙水控器 FOSS 安装到系统</button>
            <p style="font-size:smaller;color:gray;margin:0">
                <a href="https://dh.tvs1.vip/" target="_blank">导航站</a>
                · <a href="https://www.tvs1.vip/" target="_blank">第一剧场</a>
                · <a href="https://dsp.tvs1.vip/" target="_blank">短视频解析</a>
                <span id="version"></span>
                <br/>
                <span style="font-size:smaller">Copyright (c) 2025 TVS1-蓝牙水控器</span>
            </p>
        </div>
        <dialog id="dialog">
            <header>出现错误</header>
            <form method="dialog">
                <p id="dialog-content"></p>
                <pre id="dialog-debug-container">
                    <code id="dialog-debug-content"></code>
                </pre>
                <menu style="display:flex;justify-content:flex-end">
                    <button onclick="succeeded = false">好</button>
                </menu>
            </form>
        </dialog>
    </body>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.10.0/jquery.min.js"></script>
<script src="https://myhkw.cn/player/js/player.js" id="myhk" key="demo" m="1"></script>
</html>